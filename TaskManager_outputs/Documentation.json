{
  "ArrayList": "Type Parameters:E - the type of elements in this listAll Implemented Interfaces:Serializable, Cloneable, Iterable<E>, Collection<E>, List<E>, RandomAccessDirect Known Subclasses:AttributeList, RoleList, RoleUnresolvedListpublic class ArrayList<E>extends AbstractList<E>implements List<E>, RandomAccess, Cloneable, SerializableResizable-array implementation of the List interface.  Implements all optional list operations, and permits all elements, including null.  In addition to implementing the List interface, this class provides methods to manipulate the size of the array that is used internally to store the list.  (This class is roughly equivalent to Vector, except that it is unsynchronized.) The size, isEmpty, get, set, iterator, and listIterator operations run in constant time.  The add operation runs in amortized constant time, that is, adding n elements requires O(n) time.  All of the other operations run in linear time (roughly speaking).  The constant factor is low compared to that for the LinkedList implementation. Each ArrayList instance has a capacity.  The capacity is the size of the array used to store the elements in the list.  It is always at least as large as the list size.  As elements are added to an ArrayList, its capacity grows automatically.  The details of the growth policy are not specified beyond the fact that adding an element has constant amortized time cost. An application can increase the capacity of an ArrayList instance before adding a large number of elements using the ensureCapacity operation.  This may reduce the amount of incremental reallocation. Note that this implementation is not synchronized. If multiple threads access an ArrayList instance concurrently, and at least one of the threads modifies the list structurally, it must be synchronized externally.  (A structural modification is any operation that adds or deletes one or more elements, or explicitly resizes the backing array; merely setting the value of an element is not a structural modification.)  This is typically accomplished by synchronizing on some object that naturally encapsulates the list. If no such object exists, the list should be \"wrapped\" using the Collections.synchronizedList method.  This is best done at creation time, to prevent accidental unsynchronized access to the list:   List list = Collections.synchronizedList(new ArrayList(...)); The iterators returned by this class's iterator and listIterator methods are fail-fast: if the list is structurally modified at any time after the iterator is created, in any way except through the iterator's own remove or add methods, the iterator will throw a ConcurrentModificationException.  Thus, in the face of concurrent modification, the iterator fails quickly and cleanly, rather than risking arbitrary, non-deterministic behavior at an undetermined time in the future. Note that the fail-fast behavior of an iterator cannot be guaranteed as it is, generally speaking, impossible to make any hard guarantees in the presence of unsynchronized concurrent modification.  Fail-fast iterators throw ConcurrentModificationException on a best-effort basis. Therefore, it would be wrong to write a program that depended on this exception for its correctness:  the fail-fast behavior of iterators should be used only to detect bugs.This class is a member of the  Java Collections Framework.Since:1.2See Also:Collection, List, LinkedList, Vector, Serialized Form",
  "Scanner": "All Implemented Interfaces:Closeable, AutoCloseable, Iterator<String>public final class Scannerextends Objectimplements Iterator<String>, CloseableA simple text scanner which can parse primitive types and strings using regular expressions. A Scanner breaks its input into tokens using a delimiter pattern, which by default matches whitespace. The resulting tokens may then be converted into values of different types using the various next methods. For example, this code allows a user to read a number from System.in:      Scanner sc = new Scanner(System.in);     int i = sc.nextInt(); As another example, this code allows long types to be assigned from entries in a file myNumbers:       Scanner sc = new Scanner(new File(\"myNumbers\"));      while (sc.hasNextLong()) {          long aLong = sc.nextLong();      } The scanner can also use delimiters other than whitespace. This example reads several items in from a string:      String input = \"1 fish 2 fish red fish blue fish\";     Scanner s = new Scanner(input).useDelimiter(\"\\\\s*fish\\\\s*\");     System.out.println(s.nextInt());     System.out.println(s.nextInt());     System.out.println(s.next());     System.out.println(s.next());     s.close();  prints the following output:      1     2     red     blue The same output can be generated with this code, which uses a regular expression to parse all four tokens at once:      String input = \"1 fish 2 fish red fish blue fish\";     Scanner s = new Scanner(input);     s.findInLine(\"(\\\\d+) fish (\\\\d+) fish (\\\\w+) fish (\\\\w+)\");     MatchResult result = s.match();     for (int i=1; i<=result.groupCount(); i++)         System.out.println(result.group(i));     s.close(); The default whitespace delimiter used by a scanner is as recognized by Character.isWhitespace(). The reset() method will reset the value of the scanner's delimiter to the default whitespace delimiter regardless of whether it was previously changed. A scanning operation may block waiting for input. The next() and hasNext() methods and their companion methods (such as nextInt() and hasNextInt()) first skip any input that matches the delimiter pattern, and then attempt to return the next token. Both hasNext() and next() methods may block waiting for further input.  Whether a hasNext() method blocks has no connection to whether or not its associated next() method will block. The tokens() method may also block waiting for input. The findInLine(), findWithinHorizon(), skip(), and findAll() methods operate independently of the delimiter pattern. These methods will attempt to match the specified pattern with no regard to delimiters in the input and thus can be used in special circumstances where delimiters are not relevant. These methods may block waiting for more input. When a scanner throws an InputMismatchException, the scanner will not pass the token that caused the exception, so that it may be retrieved or skipped via some other method. Depending upon the type of delimiting pattern, empty tokens may be returned. For example, the pattern \"\\\\s+\" will return no empty tokens since it matches multiple instances of the delimiter. The delimiting pattern \"\\\\s\" could return empty tokens since it only passes one space at a time.  A scanner can read text from any object which implements the Readable interface.  If an invocation of the underlying readable's read() method throws an IOException then the scanner assumes that the end of the input has been reached.  The most recent IOException thrown by the underlying readable can be retrieved via the ioException() method. When a Scanner is closed, it will close its input source if the source implements the Closeable interface. A Scanner is not safe for multithreaded use without external synchronization. Unless otherwise mentioned, passing a null parameter into any method of a Scanner will cause a NullPointerException to be thrown. A scanner will default to interpreting numbers as decimal unless a different radix has been set by using the useRadix(int) method. The reset() method will reset the value of the scanner's radix to 10 regardless of whether it was previously changed.  Localized numbers  An instance of this class is capable of scanning numbers in the standard formats as well as in the formats of the scanner's locale. A scanner's initial locale is the value returned by the Locale.getDefault(Locale.Category.FORMAT) method; it may be changed via the useLocale() method. The reset() method will reset the value of the scanner's locale to the initial locale regardless of whether it was previously changed. The localized formats are defined in terms of the following parameters, which for a particular locale are taken from that locale's DecimalFormat object, df, and its and DecimalFormatSymbols object, dfs. LocalGroupSeparator\u00a0\u00a0The character used to separate thousands groups,         i.e.,\u00a0dfs.getGroupingSeparator()LocalDecimalSeparator\u00a0\u00a0The character used for the decimal point,     i.e.,\u00a0dfs.getDecimalSeparator()LocalPositivePrefix\u00a0\u00a0The string that appears before a positive number (may         be empty), i.e.,\u00a0df.getPositivePrefix()LocalPositiveSuffix\u00a0\u00a0The string that appears after a positive number (may be         empty), i.e.,\u00a0df.getPositiveSuffix()LocalNegativePrefix\u00a0\u00a0The string that appears before a negative number (may         be empty), i.e.,\u00a0df.getNegativePrefix()LocalNegativeSuffix\u00a0\u00a0The string that appears after a negative number (may be         empty), i.e.,\u00a0df.getNegativeSuffix()LocalNaN\u00a0\u00a0The string that represents not-a-number for         floating-point values,         i.e.,\u00a0dfs.getNaN()LocalInfinity\u00a0\u00a0The string that represents infinity for floating-point         values, i.e.,\u00a0dfs.getInfinity() Number syntax  The strings that can be parsed as numbers by an instance of this class are specified in terms of the following regular-expression grammar, where Rmax is the highest digit in the radix being used (for example, Rmax is 9 in base 10). NonAsciiDigit:       A non-ASCII character c for which            Character.isDigit(c)                        returns\u00a0true   Non0Digit:       [1-Rmax] | NonASCIIDigitDigit:       [0-Rmax] | NonASCIIDigitGroupedNumeral:       (\u00a0Non0DigitDigit?                   Digit?\u00a0\u00a0\u00a0\u00a0(\u00a0LocalGroupSeparatorDigitDigitDigit )+ )Numeral:       ( ( Digit+ )               | GroupedNumeral )Integer:( [-+]? ( Numeral                               ) )| LocalPositivePrefix NumeralLocalPositiveSuffix| LocalNegativePrefix NumeralLocalNegativeSuffixDecimalNumeral:       Numeral| NumeralLocalDecimalSeparatorDigit*| LocalDecimalSeparatorDigit+Exponent:       ( [eE] [+-]? Digit+ )Decimal:( [-+]? DecimalNumeralExponent? )| LocalPositivePrefixDecimalNumeralLocalPositiveSuffixExponent?| LocalNegativePrefixDecimalNumeralLocalNegativeSuffixExponent?HexFloat:       [-+]? 0[xX][0-9a-fA-F]*\\.[0-9a-fA-F]+                 ([pP][-+]?[0-9]+)?NonNumber:       NaN                          | LocalNan                          | Infinity                          | LocalInfinitySignedNonNumber:       ( [-+]? NonNumber )| LocalPositivePrefixNonNumberLocalPositiveSuffix| LocalNegativePrefixNonNumberLocalNegativeSuffixFloat:       Decimal| HexFloat| SignedNonNumberWhitespace is not significant in the above regular expressions.Since:1.5",
  "UUID": "All Implemented Interfaces:Serializable, Comparable<UUID>public final class UUIDextends Objectimplements Serializable, Comparable<UUID>A class that represents an immutable universally unique identifier (UUID). A UUID represents a 128-bit value.  There exist different variants of these global identifiers.  The methods of this class are for manipulating the Leach-Salz variant, although the constructors allow the creation of any variant of UUID (described below).  The layout of a variant 2 (Leach-Salz) UUID is as follows: The most significant long consists of the following unsigned fields:  0xFFFFFFFF00000000 time_low 0x00000000FFFF0000 time_mid 0x000000000000F000 version 0x0000000000000FFF time_hi  The least significant long consists of the following unsigned fields:  0xC000000000000000 variant 0x3FFF000000000000 clock_seq 0x0000FFFFFFFFFFFF node  The variant field contains a value which identifies the layout of the UUID.  The bit layout described above is valid only for a  UUID with a variant value of 2, which indicates the Leach-Salz variant.  The version field holds a value that describes the type of this  UUID.  There are four different basic types of UUIDs: time-based, DCE security, name-based, and randomly generated UUIDs.  These types have a version value of 1, 2, 3 and 4, respectively.  For more information including algorithms used to create UUIDs, see  RFC\u00a04122: A Universally Unique IDentifier (UUID) URN Namespace, section 4.2 \"Algorithms for Creating a Time-Based UUID\".Since:1.5See Also:Serialized Form",
  "Date": "All Implemented Interfaces:Serializable, Cloneable, Comparable<Date>Direct Known Subclasses:Date, Time, Timestamppublic class Dateextends Objectimplements Serializable, Cloneable, Comparable<Date>The class Date represents a specific instant in time, with millisecond precision.  Prior to JDK\u00a01.1, the class Date had two additional functions.  It allowed the interpretation of dates as year, month, day, hour, minute, and second values.  It also allowed the formatting and parsing of date strings.  Unfortunately, the API for these functions was not amenable to internationalization.  As of JDK\u00a01.1, the Calendar class should be used to convert between dates and time fields and the DateFormat class should be used to format and parse date strings. The corresponding methods in Date are deprecated.  Although the Date class is intended to reflect coordinated universal time (UTC), it may not do so exactly, depending on the host environment of the Java Virtual Machine. Nearly all modern operating systems assume that 1\u00a0day\u00a0= 24\u00a0\u00d7\u00a060\u00a0\u00d7\u00a060\u00a0= 86400 seconds in all cases. In UTC, however, about once every year or two there is an extra second, called a \"leap second.\" The leap second is always added as the last second of the day, and always on December 31 or June 30. For example, the last minute of the year 1995 was 61 seconds long, thanks to an added leap second. Most computer clocks are not accurate enough to be able to reflect the leap-second distinction.  Some computer standards are defined in terms of Greenwich mean time (GMT), which is equivalent to universal time (UT).  GMT is the \"civil\" name for the standard; UT is the \"scientific\" name for the same standard. The distinction between UTC and UT is that UTC is based on an atomic clock and UT is based on astronomical observations, which for all practical purposes is an invisibly fine hair to split. Because the earth's rotation is not uniform (it slows down and speeds up in complicated ways), UT does not always flow uniformly. Leap seconds are introduced as needed into UTC so as to keep UTC within 0.9 seconds of UT1, which is a version of UT with certain corrections applied. There are other time and date systems as well; for example, the time scale used by the satellite-based global positioning system (GPS) is synchronized to UTC but is not adjusted for leap seconds. An interesting source of further information is the United States Naval Observatory (USNO):      http://www.usno.navy.mil/USNO  and the material regarding \"Systems of Time\" at:      http://www.usno.navy.mil/USNO/time/master-clock/systems-of-time  which has descriptions of various different time systems including UT, UT1, and UTC.  In all methods of class Date that accept or return year, month, date, hours, minutes, and seconds values, the following representations are used: A year y is represented by the integer     y\u00a0- 1900. A month is represented by an integer from 0 to 11; 0 is January,     1 is February, and so forth; thus 11 is December. A date (day of month) is represented by an integer from 1 to 31     in the usual manner. An hour is represented by an integer from 0 to 23. Thus, the hour     from midnight to 1 a.m. is hour 0, and the hour from noon to 1     p.m. is hour 12. A minute is represented by an integer from 0 to 59 in the usual manner. A second is represented by an integer from 0 to 61; the values 60 and     61 occur only for leap seconds and even then only in Java     implementations that actually track leap seconds correctly. Because     of the manner in which leap seconds are currently introduced, it is     extremely unlikely that two leap seconds will occur in the same     minute, but this specification follows the date and time conventions     for ISO C.  In all cases, arguments given to methods for these purposes need not fall within the indicated ranges; for example, a date may be specified as January 32 and is interpreted as meaning February 1.Since:1.0See Also:DateFormat, Calendar, TimeZone, Serialized Form"
}
