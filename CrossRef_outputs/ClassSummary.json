{"JSONArray": "Java Components page\nLooking for a different release? Other releases", "JSONException": "Java Components page\nLooking for a different release? Other releases", "JSONObject": "Java Components page\nLooking for a different release? Other releases", "URIBuilder": "Java Components page\nLooking for a different release? Other releases", "QueryNode": "Java Components page\nLooking for a different release? Other releases", "FieldFormatterCleanup": "Java Components page\nLooking for a different release? Other releases", "ClearFormatter": "Java Components page\nLooking for a different release? Other releases", "RemoveBracesFormatter": "Java Components page\nLooking for a different release? Other releases", "importer": "Java Components page\nLooking for a different release? Other releases", "DefaultQueryTransformer": "Java Components page\nLooking for a different release? Other releases", "JsonReader": "Java Components page\nLooking for a different release? Other releases", "StringSimilarity": "Java Components page\nLooking for a different release? Other releases", "Author": "Java Components page\nLooking for a different release? Other releases", "AuthorList": "Java Components page\nLooking for a different release? Other releases", "BibEntry": "Java Components page\nLooking for a different release? Other releases", "StandardField": "Java Components page\nLooking for a different release? Other releases", "DOI": "Java Components page\nLooking for a different release? Other releases", "EntryType": "Java Components page\nLooking for a different release? Other releases", "StandardEntryType": "Java Components page\nLooking for a different release? Other releases", "OptionalUtil": "Java Components page\nLooking for a different release? Other releases", "MalformedURLException": "All Implemented Interfaces:\nSerializable\n\n\npublic class MalformedURLException\nextends IOException\nThrown to indicate that a malformed URL has occurred. Either no\n legal protocol could be found in a specification string or the\n string could not be parsed.\n\nSince:\n1.0\nSee Also:\nSerialized Form", "URISyntaxException": "All Implemented Interfaces:\nSerializable\n\n\npublic class URISyntaxException\nextends Exception\nChecked exception thrown to indicate that a string could not be parsed as a\n URI reference.\n\nSince:\n1.4\nSee Also:\nURI, \nSerialized Form", "URL": "All Implemented Interfaces:\nSerializable\n\n\npublic final class URL\nextends Object\nimplements Serializable\nClass URL represents a Uniform Resource\n Locator, a pointer to a \"resource\" on the World\n Wide Web. A resource can be something as simple as a file or a\n directory, or it can be a reference to a more complicated object,\n such as a query to a database or to a search engine. More\n information on the types of URLs and their formats can be found at:\n \nTypes of URL\n\n In general, a URL can be broken into several parts. Consider the\n following example:\n \n     http://www.example.com/docs/resource1.html\n \n\n The URL above indicates that the protocol to use is\n http (HyperText Transfer Protocol) and that the\n information resides on a host machine named\n www.example.com. The information on that host\n machine is named /docs/resource1.html. The exact\n meaning of this name on the host machine is both protocol\n dependent and host dependent. The information normally resides in\n a file, but it could be generated on the fly. This component of\n the URL is called the path component.\n \n A URL can optionally specify a \"port\", which is the\n port number to which the TCP connection is made on the remote host\n machine. If the port is not specified, the default port for\n the protocol is used instead. For example, the default port for\n http is 80. An alternative port could be\n specified as:\n \n     http://www.example.com:1080/docs/resource1.html\n \n\n The syntax of URL is defined by  RFC\u00a02396: Uniform\n Resource Identifiers (URI): Generic Syntax, amended by RFC\u00a02732: Format for\n Literal IPv6 Addresses in URLs. The Literal IPv6 address format\n also supports scope_ids. The syntax and usage of scope_ids is described\n here.\n \n A URL may have appended to it a \"fragment\", also known\n as a \"ref\" or a \"reference\". The fragment is indicated by the sharp\n sign character \"#\" followed by more characters. For example,\n \n     http://java.sun.com/index.html#chapter1\n \n\n This fragment is not technically part of the URL. Rather, it\n indicates that after the specified resource is retrieved, the\n application is specifically interested in that part of the\n document that has the tag chapter1 attached to it. The\n meaning of a tag is resource specific.\n \n An application can also specify a \"relative URL\",\n which contains only enough information to reach the resource\n relative to another URL. Relative URLs are frequently used within\n HTML pages. For example, if the contents of the URL:\n \n     http://java.sun.com/index.html\n \n contained within it the relative URL:\n \n     FAQ.html\n \n it would be a shorthand for:\n \n     http://java.sun.com/FAQ.html\n \n\n The relative URL need not specify all the components of a URL. If\n the protocol, host name, or port number is missing, the value is\n inherited from the fully specified URL. The file component must be\n specified. The optional fragment is not inherited.\n \n The URL class does not itself encode or decode any URL components\n according to the escaping mechanism defined in RFC2396. It is the\n responsibility of the caller to encode any fields, which need to be\n escaped prior to calling URL, and also to decode any escaped fields,\n that are returned from URL. Furthermore, because URL has no knowledge\n of URL escaping, it does not recognise equivalence between the encoded\n or decoded form of the same URL. For example, the two URLs:\n    http://foo.com/hello world/ and http://foo.com/hello%20world\n would be considered not equal to each other.\n \n Note, the URI class does perform escaping of its\n component fields in certain circumstances. The recommended way\n to manage the encoding and decoding of URLs is to use URI,\n and to convert between these two classes using toURI() and\n URI.toURL().\n \n The URLEncoder and URLDecoder classes can also be\n used, but only for HTML form encoding, which is not the same\n as the encoding scheme defined in RFC2396.\n\nSince:\n1.0\nSee Also:\nSerialized Form", "ArrayList": "Type Parameters:\nE - the type of elements in this list\n\n\nAll Implemented Interfaces:\nSerializable, Cloneable, Iterable<E>, Collection<E>, List<E>, RandomAccess\n\n\nDirect Known Subclasses:\nAttributeList, RoleList, RoleUnresolvedList\n\n\npublic class ArrayList<E>\nextends AbstractList<E>\nimplements List<E>, RandomAccess, Cloneable, Serializable\nResizable-array implementation of the List interface.  Implements\n all optional list operations, and permits all elements, including\n null.  In addition to implementing the List interface,\n this class provides methods to manipulate the size of the array that is\n used internally to store the list.  (This class is roughly equivalent to\n Vector, except that it is unsynchronized.)\n\n The size, isEmpty, get, set,\n iterator, and listIterator operations run in constant\n time.  The add operation runs in amortized constant time,\n that is, adding n elements requires O(n) time.  All of the other operations\n run in linear time (roughly speaking).  The constant factor is low compared\n to that for the LinkedList implementation.\n\n Each ArrayList instance has a capacity.  The capacity is\n the size of the array used to store the elements in the list.  It is always\n at least as large as the list size.  As elements are added to an ArrayList,\n its capacity grows automatically.  The details of the growth policy are not\n specified beyond the fact that adding an element has constant amortized\n time cost.\n\n An application can increase the capacity of an ArrayList instance\n before adding a large number of elements using the ensureCapacity\n operation.  This may reduce the amount of incremental reallocation.\n\n Note that this implementation is not synchronized.\n If multiple threads access an ArrayList instance concurrently,\n and at least one of the threads modifies the list structurally, it\n must be synchronized externally.  (A structural modification is\n any operation that adds or deletes one or more elements, or explicitly\n resizes the backing array; merely setting the value of an element is not\n a structural modification.)  This is typically accomplished by\n synchronizing on some object that naturally encapsulates the list.\n\n If no such object exists, the list should be \"wrapped\" using the\n Collections.synchronizedList\n method.  This is best done at creation time, to prevent accidental\n unsynchronized access to the list:\n   List list = Collections.synchronizedList(new ArrayList(...));\n\n The iterators returned by this class's iterator and\n listIterator methods are fail-fast:\n if the list is structurally modified at any time after the iterator is\n created, in any way except through the iterator's own\n remove or\n add methods, the iterator will throw a\n ConcurrentModificationException.  Thus, in the face of\n concurrent modification, the iterator fails quickly and cleanly, rather\n than risking arbitrary, non-deterministic behavior at an undetermined\n time in the future.\n\n Note that the fail-fast behavior of an iterator cannot be guaranteed\n as it is, generally speaking, impossible to make any hard guarantees in the\n presence of unsynchronized concurrent modification.  Fail-fast iterators\n throw ConcurrentModificationException on a best-effort basis.\n Therefore, it would be wrong to write a program that depended on this\n exception for its correctness:  the fail-fast behavior of iterators\n should be used only to detect bugs.\nThis class is a member of the\n \n Java Collections Framework.\n\nSince:\n1.2\nSee Also:\nCollection, \nList, \nLinkedList, \nVector, \nSerialized Form", "Collections": "public class Collections\nextends Object\nThis class consists exclusively of static methods that operate on or return\n collections.  It contains polymorphic algorithms that operate on\n collections, \"wrappers\", which return a new collection backed by a\n specified collection, and a few other odds and ends.\n\n The methods of this class all throw a NullPointerException\n if the collections or class objects provided to them are null.\n\n The documentation for the polymorphic algorithms contained in this class\n generally includes a brief description of the implementation.  Such\n descriptions should be regarded as implementation notes, rather than\n parts of the specification.  Implementors should feel free to\n substitute other algorithms, so long as the specification itself is adhered\n to.  (For example, the algorithm used by sort does not have to be\n a mergesort, but it does have to be stable.)\n\n The \"destructive\" algorithms contained in this class, that is, the\n algorithms that modify the collection on which they operate, are specified\n to throw UnsupportedOperationException if the collection does not\n support the appropriate mutation primitive(s), such as the set\n method.  These algorithms may, but are not required to, throw this\n exception if an invocation would have no effect on the collection.  For\n example, invoking the sort method on an unmodifiable list that is\n already sorted may or may not throw UnsupportedOperationException.\n\n This class is a member of the\n \n Java Collections Framework.\n\nSince:\n1.2\nSee Also:\nCollection, \nSet, \nList, \nMap", "List": "Type Parameters:\nE - the type of elements in this list\n\n\nAll Superinterfaces:\nCollection<E>, Iterable<E>\n\n\nAll Known Subinterfaces:\nObservableList<E>, ObservableListValue<E>, WritableListValue<E>\n\n\nAll Known Implementing Classes:\nAbstractList, AbstractSequentialList, ArrayList, AttributeList, CopyOnWriteArrayList, FilteredList, LinkedList, ListBinding, ListExpression, ListProperty, ListPropertyBase, ModifiableObservableListBase, ObservableListBase, ReadOnlyListProperty, ReadOnlyListPropertyBase, ReadOnlyListWrapper, RoleList, RoleUnresolvedList, SimpleListProperty, SortedList, Stack, TransformationList, Vector\n\n\npublic interface List<E>\nextends Collection<E>\nAn ordered collection (also known as a sequence).  The user of this\n interface has precise control over where in the list each element is\n inserted.  The user can access elements by their integer index (position in\n the list), and search for elements in the list.\n\n Unlike sets, lists typically allow duplicate elements.  More formally,\n lists typically allow pairs of elements e1 and e2\n such that e1.equals(e2), and they typically allow multiple\n null elements if they allow null elements at all.  It is not inconceivable\n that someone might wish to implement a list that prohibits duplicates, by\n throwing runtime exceptions when the user attempts to insert them, but we\n expect this usage to be rare.\n\n The List interface places additional stipulations, beyond those\n specified in the Collection interface, on the contracts of the\n iterator, add, remove, equals, and\n hashCode methods.  Declarations for other inherited methods are\n also included here for convenience.\n\n The List interface provides four methods for positional (indexed)\n access to list elements.  Lists (like Java arrays) are zero based.  Note\n that these operations may execute in time proportional to the index value\n for some implementations (the LinkedList class, for\n example). Thus, iterating over the elements in a list is typically\n preferable to indexing through it if the caller does not know the\n implementation.\n\n The List interface provides a special iterator, called a\n ListIterator, that allows element insertion and replacement, and\n bidirectional access in addition to the normal operations that the\n Iterator interface provides.  A method is provided to obtain a\n list iterator that starts at a specified position in the list.\n\n The List interface provides two methods to search for a specified\n object.  From a performance standpoint, these methods should be used with\n caution.  In many implementations they will perform costly linear\n searches.\n\n The List interface provides two methods to efficiently insert and\n remove multiple elements at an arbitrary point in the list.\n\n Note: While it is permissible for lists to contain themselves as elements,\n extreme caution is advised: the equals and hashCode\n methods are no longer well defined on such a list.\n\n Some list implementations have restrictions on the elements that\n they may contain.  For example, some implementations prohibit null elements,\n and some have restrictions on the types of their elements.  Attempting to\n add an ineligible element throws an unchecked exception, typically\n NullPointerException or ClassCastException.  Attempting\n to query the presence of an ineligible element may throw an exception,\n or it may simply return false; some implementations will exhibit the former\n behavior and some will exhibit the latter.  More generally, attempting an\n operation on an ineligible element whose completion would not result in\n the insertion of an ineligible element into the list may throw an\n exception or it may succeed, at the option of the implementation.\n Such exceptions are marked as \"optional\" in the specification for this\n interface.\n\n Unmodifiable Lists\nThe List.of and\n List.copyOf static factory methods\n provide a convenient way to create unmodifiable lists. The List\n instances created by these methods have the following characteristics:\n\n \nThey are unmodifiable. Elements cannot\n be added, removed, or replaced. Calling any mutator method on the List\n will always cause UnsupportedOperationException to be thrown.\n However, if the contained elements are themselves mutable,\n this may cause the List's contents to appear to change.\n They disallow null elements. Attempts to create them with\n null elements result in NullPointerException.\n They are serializable if all elements are serializable.\n The order of elements in the list is the same as the order of the\n provided arguments, or of the elements in the provided array.\n They are value-based.\n Callers should make no assumptions about the identity of the returned instances.\n Factories are free to create new instances or reuse existing ones. Therefore,\n identity-sensitive operations on these instances (reference equality (==),\n identity hash code, and synchronization) are unreliable and should be avoided.\n They are serialized as specified on the\n Serialized Form\n page.\n \nThis interface is a member of the\n \n Java Collections Framework.\n\nSince:\n1.2\nSee Also:\nCollection, \nSet, \nArrayList, \nLinkedList, \nVector, \nArrays.asList(Object[]), \nCollections.nCopies(int, Object), \nCollections.EMPTY_LIST, \nAbstractList, \nAbstractSequentialList", "Optional": "Type Parameters:\nT - the type of value\n\n\npublic final class Optional<T>\nextends Object\nA container object which may or may not contain a non-null value.\n If a value is present, isPresent() returns true. If no\n value is present, the object is considered empty and\n isPresent() returns false.\n\n Additional methods that depend on the presence or absence of a contained\n value are provided, such as orElse()\n (returns a default value if no value is present) and\n ifPresent() (performs an\n action if a value is present).\n\n This is a value-based\n class; use of identity-sensitive operations (including reference equality\n (==), identity hash code, or synchronization) on instances of\n Optional may have unpredictable results and should be avoided.\n\nAPI Note:\nOptional is primarily intended for use as a method return type where\n there is a clear need to represent \"no result,\" and where using null\n is likely to cause errors. A variable whose type is Optional should\n never itself be null; it should always point to an Optional\n instance.\nSince:\n1.8", "IntStream": "All Superinterfaces:\nAutoCloseable, BaseStream<Integer,IntStream>\n\n\npublic interface IntStream\nextends BaseStream<Integer,IntStream>\nA sequence of primitive int-valued elements supporting sequential and parallel\n aggregate operations.  This is the int primitive specialization of\n Stream.\n\n The following example illustrates an aggregate operation using\n Stream and IntStream, computing the sum of the weights of the\n red widgets:\n\n \n     int sum = widgets.stream()\n                      .filter(w -> w.getColor() == RED)\n                      .mapToInt(w -> w.getWeight())\n                      .sum();\n \n\n See the class documentation for Stream and the package documentation\n for java.util.stream for additional\n specification of streams, stream operations, stream pipelines, and\n parallelism.\n\nSince:\n1.8\nSee Also:\nStream, \njava.util.stream"}