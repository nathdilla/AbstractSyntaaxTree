{"StringUtil": "Java Components page\nLooking for a different release? Other releases", "OptionalUtil": "Java Components page\nLooking for a different release? Other releases", "util": "Java Components page\nLooking for a different release? Other releases", "Predicate": "Type Parameters:\nT - the type of the input to the predicate\n\n\nFunctional Interface:\nThis is a functional interface and can therefore be used as the assignment target for a lambda expression or method reference.\n\n\n@FunctionalInterface\npublic interface Predicate<T>\nRepresents a predicate (boolean-valued function) of one argument.\n\n This is a functional interface\n whose functional method is test(Object).\n\nSince:\n1.8", "Collectors": "public final class Collectors\nextends Object\nImplementations of Collector that implement various useful reduction\n operations, such as accumulating elements into collections, summarizing\n elements according to various criteria, etc.\n\n The following are examples of using the predefined collectors to perform\n common mutable reduction tasks:\n\n \n // Accumulate names into a List\n List<String> list = people.stream()\n   .map(Person::getName)\n   .collect(Collectors.toList());\n\n // Accumulate names into a TreeSet\n Set<String> set = people.stream()\n   .map(Person::getName)\n   .collect(Collectors.toCollection(TreeSet::new));\n\n // Convert elements to strings and concatenate them, separated by commas\n String joined = things.stream()\n   .map(Object::toString)\n   .collect(Collectors.joining(\", \"));\n\n // Compute sum of salaries of employee\n int total = employees.stream()\n   .collect(Collectors.summingInt(Employee::getSalary));\n\n // Group employees by department\n Map<Department, List<Employee>> byDept = employees.stream()\n   .collect(Collectors.groupingBy(Employee::getDepartment));\n\n // Compute sum of salaries by department\n Map<Department, Integer> totalByDept = employees.stream()\n   .collect(Collectors.groupingBy(Employee::getDepartment,\n                                  Collectors.summingInt(Employee::getSalary)));\n\n // Partition students into passing and failing\n Map<Boolean, List<Student>> passingFailing = students.stream()\n   .collect(Collectors.partitioningBy(s -> s.getGrade() >= PASS_THRESHOLD));\n\n \n\nSince:\n1.8"}