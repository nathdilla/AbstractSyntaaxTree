{
    "LatexParserResult": "Java Components page\nLooking for a different release? Other releases",
    "Logger": "Java Components page\nLooking for a different release? Other releases",
    "LoggerFactory": "Java Components page\nLooking for a different release? Other releases",
    "io": "Java Components page\nLooking for a different release? Other releases",
    "ClosedChannelException": "All Implemented Interfaces:\nSerializable\n\n\nDirect Known Subclasses:\nAsynchronousCloseException\n\n\npublic class ClosedChannelException\nextends IOException\nChecked exception thrown when an attempt is made to invoke or complete an\n I/O operation upon channel that is closed, or at least closed to that\n operation.  That this exception is thrown does not necessarily imply that\n the channel is completely closed.  A socket channel whose write half has\n been shut down, for example, may still be open for reading.\n\nSince:\n1.4\nSee Also:\nSerialized Form",
    "StandardCharsets": "public final class StandardCharsets\nextends Object\nConstant definitions for the standard Charsets. These\n charsets are guaranteed to be available on every implementation of the Java\n platform.\n\nSince:\n1.7\nSee Also:\nStandard Charsets",
    "Files": "public final class Files\nextends Object\nThis class consists exclusively of static methods that operate on files,\n directories, or other types of files.\n\n  In most cases, the methods defined here will delegate to the associated\n file system provider to perform the file operations.\n\nSince:\n1.7",
    "Path": "All Superinterfaces:\nComparable<Path>, Iterable<Path>, Watchable\n\n\npublic interface Path\nextends Comparable<Path>, Iterable<Path>, Watchable\nAn object that may be used to locate a file in a file system. It will\n typically represent a system dependent file path.\n\n  A Path represents a path that is hierarchical and composed of a\n sequence of directory and file name elements separated by a special separator\n or delimiter. A root component, that identifies a file system\n hierarchy, may also be present. The name element that is farthest\n from the root of the directory hierarchy is the name of a file or directory.\n The other name elements are directory names. A Path can represent a\n root, a root and a sequence of names, or simply one or more name elements.\n A Path is considered to be an empty path if it consists\n solely of one name element that is empty. Accessing a file using an\n empty path is equivalent to accessing the default directory of the\n file system. Path defines the getFileName,\n getParent, getRoot, and subpath methods to access the path components or a subsequence of its name\n elements.\n\n  In addition to accessing the components of a path, a Path also\n defines the resolve and resolveSibling methods to combine paths. The relativize\n method that can be used to construct a relative path between two paths.\n Paths can be compared, and tested against each other using\n the startsWith and endsWith methods.\n\n  This interface extends Watchable interface so that a directory\n located by a path can be registered with a WatchService and entries in the directory watched. \n WARNING: This interface is only intended to be implemented by\n those developing custom file system implementations. Methods may be added to\n this interface in future releases. \nAccessing Files\n Paths may be used with the Files class to operate on files,\n directories, and other types of files. For example, suppose we want a BufferedReader to read text from a file \"access.log\". The\n file is located in a directory \"logs\" relative to the current working\n directory and is UTF-8 encoded.\n \n     Path path = FileSystems.getDefault().getPath(\"logs\", \"access.log\");\n     BufferedReader reader = Files.newBufferedReader(path, StandardCharsets.UTF_8);\n \nInteroperability\n Paths associated with the default provider are generally interoperable\n with the java.io.File class. Paths created by other\n providers are unlikely to be interoperable with the abstract path names\n represented by java.io.File. The toPath\n method may be used to obtain a Path from the abstract path name\n represented by a java.io.File object. The resulting Path can\n be used to operate on the same file as the java.io.File object. In\n addition, the toFile method is useful to construct a \n File from the String representation of a Path.\n\n Concurrency\n Implementations of this interface are immutable and safe for use by\n multiple concurrent threads.\n\nSince:\n1.7\nSee Also:\nPaths",
    "ArrayList": "Type Parameters:\nE - the type of elements in this list\n\n\nAll Implemented Interfaces:\nSerializable, Cloneable, Iterable<E>, Collection<E>, List<E>, RandomAccess\n\n\nDirect Known Subclasses:\nAttributeList, RoleList, RoleUnresolvedList\n\n\npublic class ArrayList<E>\nextends AbstractList<E>\nimplements List<E>, RandomAccess, Cloneable, Serializable\nResizable-array implementation of the List interface.  Implements\n all optional list operations, and permits all elements, including\n null.  In addition to implementing the List interface,\n this class provides methods to manipulate the size of the array that is\n used internally to store the list.  (This class is roughly equivalent to\n Vector, except that it is unsynchronized.)\n\n The size, isEmpty, get, set,\n iterator, and listIterator operations run in constant\n time.  The add operation runs in amortized constant time,\n that is, adding n elements requires O(n) time.  All of the other operations\n run in linear time (roughly speaking).  The constant factor is low compared\n to that for the LinkedList implementation.\n\n Each ArrayList instance has a capacity.  The capacity is\n the size of the array used to store the elements in the list.  It is always\n at least as large as the list size.  As elements are added to an ArrayList,\n its capacity grows automatically.  The details of the growth policy are not\n specified beyond the fact that adding an element has constant amortized\n time cost.\n\n An application can increase the capacity of an ArrayList instance\n before adding a large number of elements using the ensureCapacity\n operation.  This may reduce the amount of incremental reallocation.\n\n Note that this implementation is not synchronized.\n If multiple threads access an ArrayList instance concurrently,\n and at least one of the threads modifies the list structurally, it\n must be synchronized externally.  (A structural modification is\n any operation that adds or deletes one or more elements, or explicitly\n resizes the backing array; merely setting the value of an element is not\n a structural modification.)  This is typically accomplished by\n synchronizing on some object that naturally encapsulates the list.\n\n If no such object exists, the list should be \"wrapped\" using the\n Collections.synchronizedList\n method.  This is best done at creation time, to prevent accidental\n unsynchronized access to the list:\n   List list = Collections.synchronizedList(new ArrayList(...));\n\n The iterators returned by this class's iterator and\n listIterator methods are fail-fast:\n if the list is structurally modified at any time after the iterator is\n created, in any way except through the iterator's own\n remove or\n add methods, the iterator will throw a\n ConcurrentModificationException.  Thus, in the face of\n concurrent modification, the iterator fails quickly and cleanly, rather\n than risking arbitrary, non-deterministic behavior at an undetermined\n time in the future.\n\n Note that the fail-fast behavior of an iterator cannot be guaranteed\n as it is, generally speaking, impossible to make any hard guarantees in the\n presence of unsynchronized concurrent modification.  Fail-fast iterators\n throw ConcurrentModificationException on a best-effort basis.\n Therefore, it would be wrong to write a program that depended on this\n exception for its correctness:  the fail-fast behavior of iterators\n should be used only to detect bugs.\nThis class is a member of the\n \n Java Collections Framework.\n\nSince:\n1.2\nSee Also:\nCollection, \nList, \nLinkedList, \nVector, \nSerialized Form",
    "Collections": "public class Collections\nextends Object\nThis class consists exclusively of static methods that operate on or return\n collections.  It contains polymorphic algorithms that operate on\n collections, \"wrappers\", which return a new collection backed by a\n specified collection, and a few other odds and ends.\n\n The methods of this class all throw a NullPointerException\n if the collections or class objects provided to them are null.\n\n The documentation for the polymorphic algorithms contained in this class\n generally includes a brief description of the implementation.  Such\n descriptions should be regarded as implementation notes, rather than\n parts of the specification.  Implementors should feel free to\n substitute other algorithms, so long as the specification itself is adhered\n to.  (For example, the algorithm used by sort does not have to be\n a mergesort, but it does have to be stable.)\n\n The \"destructive\" algorithms contained in this class, that is, the\n algorithms that modify the collection on which they operate, are specified\n to throw UnsupportedOperationException if the collection does not\n support the appropriate mutation primitive(s), such as the set\n method.  These algorithms may, but are not required to, throw this\n exception if an invocation would have no effect on the collection.  For\n example, invoking the sort method on an unmodifiable list that is\n already sorted may or may not throw UnsupportedOperationException.\n\n This class is a member of the\n \n Java Collections Framework.\n\nSince:\n1.2\nSee Also:\nCollection, \nSet, \nList, \nMap",
    "List": "Type Parameters:\nE - the type of elements in this list\n\n\nAll Superinterfaces:\nCollection<E>, Iterable<E>\n\n\nAll Known Subinterfaces:\nObservableList<E>, ObservableListValue<E>, WritableListValue<E>\n\n\nAll Known Implementing Classes:\nAbstractList, AbstractSequentialList, ArrayList, AttributeList, CopyOnWriteArrayList, FilteredList, LinkedList, ListBinding, ListExpression, ListProperty, ListPropertyBase, ModifiableObservableListBase, ObservableListBase, ReadOnlyListProperty, ReadOnlyListPropertyBase, ReadOnlyListWrapper, RoleList, RoleUnresolvedList, SimpleListProperty, SortedList, Stack, TransformationList, Vector\n\n\npublic interface List<E>\nextends Collection<E>\nAn ordered collection (also known as a sequence).  The user of this\n interface has precise control over where in the list each element is\n inserted.  The user can access elements by their integer index (position in\n the list), and search for elements in the list.\n\n Unlike sets, lists typically allow duplicate elements.  More formally,\n lists typically allow pairs of elements e1 and e2\n such that e1.equals(e2), and they typically allow multiple\n null elements if they allow null elements at all.  It is not inconceivable\n that someone might wish to implement a list that prohibits duplicates, by\n throwing runtime exceptions when the user attempts to insert them, but we\n expect this usage to be rare.\n\n The List interface places additional stipulations, beyond those\n specified in the Collection interface, on the contracts of the\n iterator, add, remove, equals, and\n hashCode methods.  Declarations for other inherited methods are\n also included here for convenience.\n\n The List interface provides four methods for positional (indexed)\n access to list elements.  Lists (like Java arrays) are zero based.  Note\n that these operations may execute in time proportional to the index value\n for some implementations (the LinkedList class, for\n example). Thus, iterating over the elements in a list is typically\n preferable to indexing through it if the caller does not know the\n implementation.\n\n The List interface provides a special iterator, called a\n ListIterator, that allows element insertion and replacement, and\n bidirectional access in addition to the normal operations that the\n Iterator interface provides.  A method is provided to obtain a\n list iterator that starts at a specified position in the list.\n\n The List interface provides two methods to search for a specified\n object.  From a performance standpoint, these methods should be used with\n caution.  In many implementations they will perform costly linear\n searches.\n\n The List interface provides two methods to efficiently insert and\n remove multiple elements at an arbitrary point in the list.\n\n Note: While it is permissible for lists to contain themselves as elements,\n extreme caution is advised: the equals and hashCode\n methods are no longer well defined on such a list.\n\n Some list implementations have restrictions on the elements that\n they may contain.  For example, some implementations prohibit null elements,\n and some have restrictions on the types of their elements.  Attempting to\n add an ineligible element throws an unchecked exception, typically\n NullPointerException or ClassCastException.  Attempting\n to query the presence of an ineligible element may throw an exception,\n or it may simply return false; some implementations will exhibit the former\n behavior and some will exhibit the latter.  More generally, attempting an\n operation on an ineligible element whose completion would not result in\n the insertion of an ineligible element into the list may throw an\n exception or it may succeed, at the option of the implementation.\n Such exceptions are marked as \"optional\" in the specification for this\n interface.\n\n Unmodifiable Lists\nThe List.of and\n List.copyOf static factory methods\n provide a convenient way to create unmodifiable lists. The List\n instances created by these methods have the following characteristics:\n\n \nThey are unmodifiable. Elements cannot\n be added, removed, or replaced. Calling any mutator method on the List\n will always cause UnsupportedOperationException to be thrown.\n However, if the contained elements are themselves mutable,\n this may cause the List's contents to appear to change.\n They disallow null elements. Attempts to create them with\n null elements result in NullPointerException.\n They are serializable if all elements are serializable.\n The order of elements in the list is the same as the order of the\n provided arguments, or of the elements in the provided array.\n They are value-based.\n Callers should make no assumptions about the identity of the returned instances.\n Factories are free to create new instances or reuse existing ones. Therefore,\n identity-sensitive operations on these instances (reference equality (==),\n identity hash code, and synchronization) are unreliable and should be avoided.\n They are serialized as specified on the\n Serialized Form\n page.\n \nThis interface is a member of the\n \n Java Collections Framework.\n\nSince:\n1.2\nSee Also:\nCollection, \nSet, \nArrayList, \nLinkedList, \nVector, \nArrays.asList(Object[]), \nCollections.nCopies(int, Object), \nCollections.EMPTY_LIST, \nAbstractList, \nAbstractSequentialList",
    "Matcher": "All Implemented Interfaces:\nMatchResult\n\n\npublic final class Matcher\nextends Object\nimplements MatchResult\nAn engine that performs match operations on a character sequence by interpreting a Pattern.\n\n  A matcher is created from a pattern by invoking the pattern's matcher method.  Once created, a matcher can be used to\n perform three different kinds of match operations:\n\n \n The matches method attempts to match the entire\n   input sequence against the pattern.  \n The lookingAt method attempts to match the\n   input sequence, starting at the beginning, against the pattern.  \n The find method scans the input sequence looking for\n   the next subsequence that matches the pattern.  \n\n Each of these methods returns a boolean indicating success or failure.\n More information about a successful match can be obtained by querying the\n state of the matcher.\n\n  A matcher finds matches in a subset of its input called the\n region. By default, the region contains all of the matcher's input.\n The region can be modified via the region method and queried\n via the regionStart and regionEnd\n methods. The way that the region boundaries interact with some pattern\n constructs can be changed. See useAnchoringBounds and useTransparentBounds\n for more details.\n\n  This class also defines methods for replacing matched subsequences with\n new strings whose contents can, if desired, be computed from the match\n result.  The appendReplacement and appendTail methods can be used in tandem in order to collect\n the result into an existing string buffer or string builder. Alternatively,\n the more convenient replaceAll method can be used to\n create a string in which every matching subsequence in the input sequence\n is replaced.\n\n  The explicit state of a matcher includes the start and end indices of\n the most recent successful match.  It also includes the start and end\n indices of the input subsequence captured by each capturing group in the pattern as well as a total\n count of such subsequences.  As a convenience, methods are also provided for\n returning these captured subsequences in string form.\n\n  The explicit state of a matcher is initially undefined; attempting to\n query any part of it before a successful match will cause an IllegalStateException to be thrown.  The explicit state of a matcher is\n recomputed by every match operation.\n\n  The implicit state of a matcher includes the input character sequence as\n well as the append position, which is initially zero and is updated\n by the appendReplacement method.\n\n  A matcher may be reset explicitly by invoking its reset()\n method or, if a new input sequence is desired, its reset(CharSequence) method.  Resetting a\n matcher discards its explicit state information and sets the append position\n to zero.\n\n  Instances of this class are not safe for use by multiple concurrent\n threads. \n\nSince:\n1.4",
    "Pattern": "All Implemented Interfaces:\nSerializable\n\n\npublic final class Pattern\nextends Object\nimplements Serializable\nA compiled representation of a regular expression.\n\n  A regular expression, specified as a string, must first be compiled into\n an instance of this class.  The resulting pattern can then be used to create\n a Matcher object that can match arbitrary character sequences against the regular\n expression.  All of the state involved in performing a match resides in the\n matcher, so many matchers can share the same pattern.\n\n  A typical invocation sequence is thus\n\n \n Pattern p = Pattern.compile(\"a*b\");\n Matcher m = p.matcher(\"aaaaab\");\n boolean b = m.matches();\n A matches method is defined by this class as a\n convenience for when a regular expression is used just once.  This method\n compiles an expression and matches an input sequence against it in a single\n invocation.  The statement\n\n \n boolean b = Pattern.matches(\"a*b\", \"aaaaab\");\n\n is equivalent to the three statements above, though for repeated matches it\n is less efficient since it does not allow the compiled pattern to be reused.\n\n  Instances of this class are immutable and are safe for use by multiple\n concurrent threads.  Instances of the Matcher class are not safe for\n such use.\n\n\n Summary of regular-expression constructs\n\nRegular expression constructs, and what they match\n\n\nConstruct\nMatches\n\n\n\nCharacters\nx\nThe character x\n\\\\\nThe backslash character\n\\0n\nThe character with octal value 0n\n         (0\u00a0<=\u00a0n\u00a0<=\u00a07)\n\\0nn\nThe character with octal value 0nn\n         (0\u00a0<=\u00a0n\u00a0<=\u00a07)\n\\0mnn\nThe character with octal value 0mnn\n         (0\u00a0<=\u00a0m\u00a0<=\u00a03,\n         0\u00a0<=\u00a0n\u00a0<=\u00a07)\n\\xhh\nThe character with hexadecimal value 0xhh\n\\uhhhh\nThe character with hexadecimal\u00a0value\u00a00xhhhh\n\\x{h...h}\nThe character with hexadecimal value 0xh...h\n         (Character.MIN_CODE_POINT\n         \u00a0<=\u00a00xh...h\u00a0<=\u00a0\n          Character.MAX_CODE_POINT)\n\\N{name}\nThe character with Unicode character name 'name'\n\\t\nThe tab character ('\\u0009')\n\\n\nThe newline (line feed) character ('\\u000A')\n\\r\nThe carriage-return character ('\\u000D')\n\\f\nThe form-feed character ('\\u000C')\n\\a\nThe alert (bell) character ('\\u0007')\n\\e\nThe escape character ('\\u001B')\n\\cx\nThe control character corresponding to x\nCharacter classes\n[abc]\na, b, or c (simple class)\n[^abc]\nAny character except a, b, or c (negation)\n[a-zA-Z]\na through z\n         or A through Z, inclusive (range)\n[a-d[m-p]]\na through d,\n      or m through p: [a-dm-p] (union)\n[a-z&&[def]]\nd, e, or f (intersection)\n[a-z&&[^bc]]\na through z,\n         except for b and c: [ad-z] (subtraction)\n[a-z&&[^m-p]]\na through z,\n          and not m through p: [a-lq-z](subtraction)\nPredefined character classes\n.\nAny character (may or may not match line terminators)\n\\d\nA digit: [0-9]\n\\D\nA non-digit: [^0-9]\n\\h\nA horizontal whitespace character:\n     [ \\t\\xA0\\u1680\\u180e\\u2000-\\u200a\\u202f\\u205f\\u3000]\n\\H\nA non-horizontal whitespace character: [^\\h]\n\\s\nA whitespace character: [ \\t\\n\\x0B\\f\\r]\n\\S\nA non-whitespace character: [^\\s]\n\\v\nA vertical whitespace character: [\\n\\x0B\\f\\r\\x85\\u2028\\u2029]\n\n\\V\nA non-vertical whitespace character: [^\\v]\n\\w\nA word character: [a-zA-Z_0-9]\n\\W\nA non-word character: [^\\w]\nPOSIX character classes (US-ASCII only)\n\\p{Lower}\nA lower-case alphabetic character: [a-z]\n\\p{Upper}\nAn upper-case alphabetic character:[A-Z]\n\\p{ASCII}\nAll ASCII:[\\x00-\\x7F]\n\\p{Alpha}\nAn alphabetic character:[\\p{Lower}\\p{Upper}]\n\\p{Digit}\nA decimal digit: [0-9]\n\\p{Alnum}\nAn alphanumeric character:[\\p{Alpha}\\p{Digit}]\n\\p{Punct}\nPunctuation: One of !\"#$%&'()*+,-./:;<=>?@[\\]^_`{|}~\n\n\\p{Graph}\nA visible character: [\\p{Alnum}\\p{Punct}]\n\\p{Print}\nA printable character: [\\p{Graph}\\x20]\n\\p{Blank}\nA space or a tab: [ \\t]\n\\p{Cntrl}\nA control character: [\\x00-\\x1F\\x7F]\n\\p{XDigit}\nA hexadecimal digit: [0-9a-fA-F]\n\\p{Space}\nA whitespace character: [ \\t\\n\\x0B\\f\\r]\njava.lang.Character classes (simple java character type)\n\\p{javaLowerCase}\nEquivalent to java.lang.Character.isLowerCase()\n\\p{javaUpperCase}\nEquivalent to java.lang.Character.isUpperCase()\n\\p{javaWhitespace}\nEquivalent to java.lang.Character.isWhitespace()\n\\p{javaMirrored}\nEquivalent to java.lang.Character.isMirrored()\nClasses for Unicode scripts, blocks, categories and binary properties\n\\p{IsLatin}\nA Latin\u00a0script character (script)\n\\p{InGreek}\nA character in the Greek\u00a0block (block)\n\\p{Lu}\nAn uppercase letter (category)\n\\p{IsAlphabetic}\nAn alphabetic character (binary property)\n\\p{Sc}\nA currency symbol\n\\P{InGreek}\nAny character except one in the Greek block (negation)\n[\\p{L}&&[^\\p{Lu}]]\nAny letter except an uppercase letter (subtraction)\nBoundary matchers\n^\nThe beginning of a line\n$\nThe end of a line\n\\b\nA word boundary\n\\b{g}\nA Unicode extended grapheme cluster boundary\n\\B\nA non-word boundary\n\\A\nThe beginning of the input\n\\G\nThe end of the previous match\n\\Z\nThe end of the input but for the final\n         terminator, if\u00a0any\n\\z\nThe end of the input\nLinebreak matcher\n\\R\nAny Unicode linebreak sequence, is equivalent to\n     \\u000D\\u000A|[\\u000A\\u000B\\u000C\\u000D\\u0085\\u2028\\u2029]\n     \nUnicode Extended Grapheme matcher\n\\X\nAny Unicode extended grapheme cluster\nGreedy quantifiers\nX?\nX, once or not at all\nX*\nX, zero or more times\nX+\nX, one or more times\nX{n}\nX, exactly n times\nX{n,}\nX, at least n times\nX{n,m}\nX, at least n but not more than m times\nReluctant quantifiers\nX??\nX, once or not at all\nX*?\nX, zero or more times\nX+?\nX, one or more times\nX{n}?\nX, exactly n times\nX{n,}?\nX, at least n times\nX{n,m}?\nX, at least n but not more than m times\nPossessive quantifiers\nX?+\nX, once or not at all\nX*+\nX, zero or more times\nX++\nX, one or more times\nX{n}+\nX, exactly n times\nX{n,}+\nX, at least n times\nX{n,m}+\nX, at least n but not more than m times\nLogical operators\nXY\nX followed by Y\nX|Y\nEither X or Y\n(X)\nX, as a capturing group\nBack references\n\\n\nWhatever the nth\ncapturing group matched\n\\k<name>\nWhatever the\n     named-capturing group \"name\" matched\nQuotation\n\\\nNothing, but quotes the following character\n\\Q\nNothing, but quotes all characters until \\E\n\\E\nNothing, but ends quoting started by \\Q\n\nSpecial constructs (named-capturing and non-capturing)\n(?<name>X)\nX, as a named-capturing group\n(?:X)\nX, as a non-capturing group\n(?idmsuxU-idmsuxU)\u00a0\nNothing, but turns match flags i\nd m s\nu x U\n on - off\n(?idmsux-idmsux:X)\u00a0\u00a0\nX, as a non-capturing group with the\n         given flags i d\nm s u\nx on - off\n(?=X)\nX, via zero-width positive lookahead\n(?!X)\nX, via zero-width negative lookahead\n(?<=X)\nX, via zero-width positive lookbehind\n(?<!X)\nX, via zero-width negative lookbehind\n(?>X)\nX, as an independent, non-capturing group\n\n\n\nBackslashes, escapes, and quoting\n The backslash character ('\\') serves to introduce escaped\n constructs, as defined in the table above, as well as to quote characters\n that otherwise would be interpreted as unescaped constructs.  Thus the\n expression \\\\ matches a single backslash and \\{ matches a\n left brace.\n\n  It is an error to use a backslash prior to any alphabetic character that\n does not denote an escaped construct; these are reserved for future\n extensions to the regular-expression language.  A backslash may be used\n prior to a non-alphabetic character regardless of whether that character is\n part of an unescaped construct.\n\n  Backslashes within string literals in Java source code are interpreted\n as required by\n The Java\u2122 Language Specification\n as either Unicode escapes (section 3.3) or other character escapes (section 3.10.6)\n It is therefore necessary to double backslashes in string\n literals that represent regular expressions to protect them from\n interpretation by the Java bytecode compiler.  The string literal\n \"\\b\", for example, matches a single backspace character when\n interpreted as a regular expression, while \"\\\\b\" matches a\n word boundary.  The string literal \"\\(hello\\)\" is illegal\n and leads to a compile-time error; in order to match the string\n (hello) the string literal \"\\\\(hello\\\\)\"\n must be used.\n\n Character Classes\n Character classes may appear within other character classes, and\n    may be composed by the union operator (implicit) and the intersection\n    operator (&&).\n    The union operator denotes a class that contains every character that is\n    in at least one of its operand classes.  The intersection operator\n    denotes a class that contains every character that is in both of its\n    operand classes.\n\n     The precedence of character-class operators is as follows, from\n    highest to lowest:\n\n    \nPrecedence of character class operators.\n\nPrecedenceNameExample\n      \n\n1\nLiteral escape\u00a0\u00a0\u00a0\u00a0\n\\x\n2\nGrouping\n[...]\n3\nRange\na-z\n4\nUnion\n[a-e][i-u]\n5\nIntersection\n[a-z&&[aeiou]]\n\n\n Note that a different set of metacharacters are in effect inside\n    a character class than outside a character class. For instance, the\n    regular expression . loses its special meaning inside a\n    character class, while the expression - becomes a range\n    forming metacharacter.\n\n Line terminators\n A line terminator is a one- or two-character sequence that marks\n the end of a line of the input character sequence.  The following are\n recognized as line terminators:\n\n \n A newline (line feed) character ('\\n'),\n\n    A carriage-return character followed immediately by a newline\n   character (\"\\r\\n\"),\n\n    A standalone carriage-return character ('\\r'),\n\n    A next-line character ('\\u0085'),\n\n    A line-separator character ('\\u2028'), or\n\n    A paragraph-separator character ('\\u2029').\n\n \nIf UNIX_LINES mode is activated, then the only line terminators\n recognized are newline characters.\n\n  The regular expression . matches any character except a line\n terminator unless the DOTALL flag is specified.\n\n  By default, the regular expressions ^ and $ ignore\n line terminators and only match at the beginning and the end, respectively,\n of the entire input sequence. If MULTILINE mode is activated then\n ^ matches at the beginning of input and after any line terminator\n except at the end of input. When in MULTILINE mode $\n matches just before a line terminator or the end of the input sequence.\n\n Groups and capturing\nGroup number\n Capturing groups are numbered by counting their opening parentheses from\n left to right.  In the expression ((A)(B(C))), for example, there\n are four such groups: \n\n ((A)(B(C)))\n (A)\n (B(C))\n (C)\n\n Group zero always stands for the entire expression.\n\n  Capturing groups are so named because, during a match, each subsequence\n of the input sequence that matches such a group is saved.  The captured\n subsequence may be used later in the expression, via a back reference, and\n may also be retrieved from the matcher once the match operation is complete.\n\n Group name\nA capturing group can also be assigned a \"name\", a named-capturing group,\n and then be back-referenced later by the \"name\". Group names are composed of\n the following characters. The first character must be a letter.\n\n \n The uppercase letters 'A' through 'Z'\n        ('\\u0041'\u00a0through\u00a0'\\u005a'),\n    The lowercase letters 'a' through 'z'\n        ('\\u0061'\u00a0through\u00a0'\\u007a'),\n    The digits '0' through '9'\n        ('\\u0030'\u00a0through\u00a0'\\u0039'),\n \n A named-capturing group is still numbered as described in\n Group number.\n\n  The captured input associated with a group is always the subsequence\n that the group most recently matched.  If a group is evaluated a second time\n because of quantification then its previously-captured value, if any, will\n be retained if the second evaluation fails.  Matching the string\n \"aba\" against the expression (a(b)?)+, for example, leaves\n group two set to \"b\".  All captured input is discarded at the\n beginning of each match.\n\n  Groups beginning with (? are either pure, non-capturing groups\n that do not capture text and do not count towards the group total, or\n named-capturing group.\n\n  Unicode support \n This class is in conformance with Level 1 of Unicode Technical\n Standard #18: Unicode Regular Expression, plus RL2.1\n Canonical Equivalents.\n \nUnicode escape sequences such as \\u2014 in Java source code\n are processed as described in section 3.3 of\n The Java\u2122 Language Specification.\n Such escape sequences are also implemented directly by the regular-expression\n parser so that Unicode escapes can be used in expressions that are read from\n files or from the keyboard.  Thus the strings \"\\u2014\" and\n \"\\\\u2014\", while not equal, compile into the same pattern, which\n matches the character with hexadecimal value 0x2014.\n \n A Unicode character can also be represented by using its Hex notation\n (hexadecimal code point value) directly as described in construct\n \\x{...}, for example a supplementary character U+2011F can be\n specified as \\x{2011F}, instead of two consecutive Unicode escape\n sequences of the surrogate pair \\uD840\\uDD1F.\n \nUnicode character names are supported by the named character construct\n \\N{...}, for example, \\N{WHITE SMILING FACE}\n specifies character \\u263A. The character names supported\n by this class are the valid Unicode character names matched by\n Character.codePointOf(name).\n \n\nUnicode extended grapheme clusters are supported by the grapheme\n cluster matcher \\X and the corresponding boundary matcher \\b{g}.\n \n Unicode scripts, blocks, categories and binary properties are written with\n the \\p and \\P constructs as in Perl.\n \\p{prop} matches if\n the input has the property prop, while \\P{prop}\n does not match if the input has that property.\n \n Scripts, blocks, categories and binary properties can be used both inside\n and outside of a character class.\n\n \nScripts are specified either with the prefix Is, as in\n IsHiragana, or by using  the script keyword (or its short\n form sc) as in script=Hiragana or sc=Hiragana.\n \n The script names supported by Pattern are the valid script names\n accepted and defined by\n UnicodeScript.forName.\n\n \nBlocks are specified with the prefix In, as in\n InMongolian, or by using the keyword block (or its short\n form blk) as in block=Mongolian or blk=Mongolian.\n \n The block names supported by Pattern are the valid block names\n accepted and defined by\n UnicodeBlock.forName.\n \nCategories may be specified with the optional prefix Is:\n Both \\p{L} and \\p{IsL} denote the category of Unicode\n letters. Same as scripts and blocks, categories can also be specified\n by using the keyword general_category (or its short form\n gc) as in general_category=Lu or gc=Lu.\n \n The supported categories are those of\n \nThe Unicode Standard in the version specified by the\n Character class. The category names are those\n defined in the Standard, both normative and informative.\n \nBinary properties are specified with the prefix Is, as in\n IsAlphabetic. The supported binary properties by Pattern\n are\n \n Alphabetic\n    Ideographic\n    Letter\n    Lowercase\n    Uppercase\n    Titlecase\n    Punctuation\n    Control\n    White_Space\n    Digit\n    Hex_Digit\n    Join_Control\n    Noncharacter_Code_Point\n    Assigned\n \n\n The following Predefined Character classes and POSIX character classes\n are in conformance with the recommendation of Annex C: Compatibility Properties\n of Unicode Regular Expression\n , when UNICODE_CHARACTER_CLASS flag is specified.\n\n \npredefined and posix character classes in Unicode mode\n\n\nClasses\nMatches\n\n\n\n\\p{Lower}\nA lowercase character:\\p{IsLowercase}\n\\p{Upper}\nAn uppercase character:\\p{IsUppercase}\n\\p{ASCII}\nAll ASCII:[\\x00-\\x7F]\n\\p{Alpha}\nAn alphabetic character:\\p{IsAlphabetic}\n\\p{Digit}\nA decimal digit character:\\p{IsDigit}\n\\p{Alnum}\nAn alphanumeric character:[\\p{IsAlphabetic}\\p{IsDigit}]\n\\p{Punct}\nA punctuation character:\\p{IsPunctuation}\n\\p{Graph}\nA visible character: [^\\p{IsWhite_Space}\\p{gc=Cc}\\p{gc=Cs}\\p{gc=Cn}]\n\\p{Print}\nA printable character: [\\p{Graph}\\p{Blank}&&[^\\p{Cntrl}]]\n\\p{Blank}\nA space or a tab: [\\p{IsWhite_Space}&&[^\\p{gc=Zl}\\p{gc=Zp}\\x0a\\x0b\\x0c\\x0d\\x85]]\n\\p{Cntrl}\nA control character: \\p{gc=Cc}\n\\p{XDigit}\nA hexadecimal digit: [\\p{gc=Nd}\\p{IsHex_Digit}]\n\\p{Space}\nA whitespace character:\\p{IsWhite_Space}\n\\d\nA digit: \\p{IsDigit}\n\\D\nA non-digit: [^\\d]\n\\s\nA whitespace character: \\p{IsWhite_Space}\n\\S\nA non-whitespace character: [^\\s]\n\\w\nA word character: [\\p{Alpha}\\p{gc=Mn}\\p{gc=Me}\\p{gc=Mc}\\p{Digit}\\p{gc=Pc}\\p{IsJoin_Control}]\n\\W\nA non-word character: [^\\w]\n\n\n\n\n Categories that behave like the java.lang.Character\n boolean ismethodname methods (except for the deprecated ones) are\n available through the same \\p{prop} syntax where\n the specified property has the name javamethodname.\n\n  Comparison to Perl 5 \nThe Pattern engine performs traditional NFA-based matching\n with ordered alternation as occurs in Perl 5.\n\n  Perl constructs not supported by this class: \n\n The backreference constructs, \\g{n} for\n    the nthcapturing group and\n    \\g{name} for\n    named-capturing group.\n    \n The conditional constructs\n    (?(condition)X) and\n    (?(condition)X|Y),\n    \n The embedded code constructs (?{code})\n    and (??{code}),\n The embedded comment syntax (?#comment), and \n The preprocessing operations \\l \\u,\n    \\L, and \\U.  \n\n Constructs supported by this class but not by Perl: \n\n Character-class union and intersection as described\n    above.\n\n Notable differences from Perl: \n\n In Perl, \\1 through \\9 are always interpreted\n    as back references; a backslash-escaped number greater than 9 is\n    treated as a back reference if at least that many subexpressions exist,\n    otherwise it is interpreted, if possible, as an octal escape.  In this\n    class octal escapes must always begin with a zero. In this class,\n    \\1 through \\9 are always interpreted as back\n    references, and a larger number is accepted as a back reference if at\n    least that many subexpressions exist at that point in the regular\n    expression, otherwise the parser will drop digits until the number is\n    smaller or equal to the existing number of groups or it is one digit.\n    \n Perl uses the g flag to request a match that resumes\n    where the last match left off.  This functionality is provided implicitly\n    by the Matcher class: Repeated invocations of the find method will resume where the last match left off,\n    unless the matcher is reset.  \n In Perl, embedded flags at the top level of an expression affect\n    the whole expression.  In this class, embedded flags always take effect\n    at the point at which they appear, whether they are at the top level or\n    within a group; in the latter case, flags are restored at the end of the\n    group just as in Perl.  \n\n For a more precise description of the behavior of regular expression\n constructs, please see \nMastering Regular Expressions, 3nd Edition, Jeffrey E. F. Friedl,\n O'Reilly and Associates, 2006.\n\n\nSince:\n1.4\nSee Also:\nString.split(String, int), \nString.split(String), \nSerialized Form"
}