{
    "Toolkit": "public abstract class Toolkit\nextends Object\nThis class is the abstract superclass of all actual\n implementations of the Abstract Window Toolkit. Subclasses of\n the Toolkit class are used to bind the various components\n to particular native toolkit implementations.\n \n Many GUI events may be delivered to user\n asynchronously, if the opposite is not specified explicitly.\n As well as\n many GUI operations may be performed asynchronously.\n This fact means that if the state of a component is set, and then\n the state immediately queried, the returned value may not yet\n reflect the requested change.  This behavior includes, but is not\n limited to:\n \nScrolling to a specified position.\n For example, calling ScrollPane.setScrollPosition\n     and then getScrollPosition may return an incorrect\n     value if the original request has not yet been processed.\n\n Moving the focus from one component to another.\n For more information, see\n Timing\n Focus Transfers, a section in\n The Swing\n Tutorial.\n\n Making a top-level container visible.\n Calling setVisible(true) on a Window,\n     Frame or Dialog may occur\n     asynchronously.\n\n Setting the size or location of a top-level container.\n Calls to setSize, setBounds or\n     setLocation on a Window,\n     Frame or Dialog are forwarded\n     to the underlying window management system and may be\n     ignored or modified.  See Window for\n     more information.\n \n\n Most applications should not call any of the methods in this\n class directly. The methods defined by Toolkit are\n the \"glue\" that joins the platform-independent classes in the\n java.awt package with their counterparts in\n java.awt.peer. Some methods defined by\n Toolkit query the native operating system directly.\n\nSince:\n1.0",
    "DataFlavor": "All Implemented Interfaces:\nExternalizable, Serializable, Cloneable\n\n\nDirect Known Subclasses:\nActivationDataFlavor\n\n\npublic class DataFlavor\nextends Object\nimplements Externalizable, Cloneable\nA DataFlavor provides meta information about data. DataFlavor\n is typically used to access data on the clipboard, or during a drag and drop\n operation.\n \n An instance of DataFlavor encapsulates a content type as defined in\n RFC 2045 and\n RFC 2046. A content type is\n typically referred to as a MIME type.\n \n A content type consists of a media type (referred to as the primary type), a\n subtype, and optional parameters. See\n RFC 2045 for details on the\n syntax of a MIME type.\n \n The JRE data transfer implementation interprets the parameter\n \"class\" of a MIME type as a representation class. The\n representation class reflects the class of the object being transferred. In\n other words, the representation class is the type of object returned by\n Transferable.getTransferData(java.awt.datatransfer.DataFlavor). For example, the MIME type of\n imageFlavor is \"image/x-java-image;class=java.awt.Image\",\n the primary type is image, the subtype is x-java-image, and\n the representation class is java.awt.Image. When\n getTransferData is invoked with a DataFlavor of\n imageFlavor, an instance of java.awt.Image is returned. It's\n important to note that DataFlavor does no error checking against the\n representation class. It is up to consumers of DataFlavor, such as\n Transferable, to honor the representation class.\n \n Note, if you do not specify a representation class when creating a\n DataFlavor, the default representation class is used. See appropriate\n documentation for DataFlavor's constructors.\n \n Also, DataFlavor instances with the \"text\" primary MIME\n type may have a \"charset\" parameter. Refer to\n RFC 2046 and\n selectBestTextFlavor(java.awt.datatransfer.DataFlavor[]) for details on \"text\" MIME types and\n the \"charset\" parameter.\n \n Equality of DataFlavors is determined by the primary type, subtype,\n and representation class. Refer to equals(DataFlavor) for details.\n When determining equality, any optional parameters are ignored. For example,\n the following produces two DataFlavors that are considered identical:\n \n   DataFlavor flavor1 = new DataFlavor(Object.class, \"X-test/test; class=<java.lang.Object>; foo=bar\");\n   DataFlavor flavor2 = new DataFlavor(Object.class, \"X-test/test; class=<java.lang.Object>; x=y\");\n   // The following returns true.\n   flavor1.equals(flavor2);\n \n As mentioned, flavor1 and flavor2 are considered identical.\n As such, asking a Transferable for either DataFlavor returns\n the same results.\n \n For more information on using data transfer with Swing see the\n How\n to Use Drag and Drop and Data Transfer, section in\n The Java Tutorial.\n\nSince:\n1.1\nSee Also:\nSerialized Form",
    "StringSelection": "All Implemented Interfaces:\nClipboardOwner, Transferable\n\n\npublic class StringSelection\nextends Object\nimplements Transferable, ClipboardOwner\nA Transferable which implements the capability required to transfer a\n String.\n \n This Transferable properly supports DataFlavor.stringFlavor\n and all equivalent flavors. Support for DataFlavor.plainTextFlavor\n and all equivalent flavors is deprecated. No other DataFlavors\n are supported.\n\nSince:\n1.1\nSee Also:\nDataFlavor.stringFlavor, \nDataFlavor.plainTextFlavor",
    "Transferable": "All Known Implementing Classes:\nDataHandler, DropTargetContext.TransferableProxy, StringSelection\n\n\npublic interface Transferable\nDefines the interface for classes that can be used to provide data for a\n transfer operation.\n \n For information on using data transfer with Swing, see\n \n How to Use Drag and Drop and Data Transfer, a section in\n The Java Tutorial, for more information.\n\nSince:\n1.1",
    "UnsupportedFlavorException": "All Implemented Interfaces:\nSerializable\n\n\npublic class UnsupportedFlavorException\nextends Exception\nSignals that the requested data is not supported in this flavor.\n\nSince:\n1.1\nSee Also:\nTransferable.getTransferData(java.awt.datatransfer.DataFlavor), \nSerialized Form",
    "IOException": "All Implemented Interfaces:\nSerializable\n\n\nDirect Known Subclasses:\nAttachOperationFailedException, ChangedCharSetException, CharacterCodingException, CharConversionException, ClosedChannelException, ClosedConnectionException, EOFException, FileLockInterruptionException, FileNotFoundException, FilerException, FileSystemException, HttpRetryException, HttpTimeoutException, IIOException, InterruptedByTimeoutException, InterruptedIOException, InvalidPropertiesFormatException, JMXProviderException, JMXServerErrorException, LoadException, MalformedURLException, ObjectStreamException, ProtocolException, RemoteException, SaslException, SocketException, SSLException, SyncFailedException, TransportTimeoutException, UnknownHostException, UnknownServiceException, UnsupportedDataTypeException, UnsupportedEncodingException, UserPrincipalNotFoundException, UTFDataFormatException, WebSocketHandshakeException, ZipException\n\n\npublic class IOException\nextends Exception\nSignals that an I/O exception of some sort has occurred. This\n class is the general class of exceptions produced by failed or\n interrupted I/O operations.\n\nSince:\n1.0\nSee Also:\nInputStream, \nOutputStream, \nSerialized Form",
    "List": "Type Parameters:\nE - the type of elements in this list\n\n\nAll Superinterfaces:\nCollection<E>, Iterable<E>\n\n\nAll Known Subinterfaces:\nObservableList<E>, ObservableListValue<E>, WritableListValue<E>\n\n\nAll Known Implementing Classes:\nAbstractList, AbstractSequentialList, ArrayList, AttributeList, CopyOnWriteArrayList, FilteredList, LinkedList, ListBinding, ListExpression, ListProperty, ListPropertyBase, ModifiableObservableListBase, ObservableListBase, ReadOnlyListProperty, ReadOnlyListPropertyBase, ReadOnlyListWrapper, RoleList, RoleUnresolvedList, SimpleListProperty, SortedList, Stack, TransformationList, Vector\n\n\npublic interface List<E>\nextends Collection<E>\nAn ordered collection (also known as a sequence).  The user of this\n interface has precise control over where in the list each element is\n inserted.  The user can access elements by their integer index (position in\n the list), and search for elements in the list.\n\n Unlike sets, lists typically allow duplicate elements.  More formally,\n lists typically allow pairs of elements e1 and e2\n such that e1.equals(e2), and they typically allow multiple\n null elements if they allow null elements at all.  It is not inconceivable\n that someone might wish to implement a list that prohibits duplicates, by\n throwing runtime exceptions when the user attempts to insert them, but we\n expect this usage to be rare.\n\n The List interface places additional stipulations, beyond those\n specified in the Collection interface, on the contracts of the\n iterator, add, remove, equals, and\n hashCode methods.  Declarations for other inherited methods are\n also included here for convenience.\n\n The List interface provides four methods for positional (indexed)\n access to list elements.  Lists (like Java arrays) are zero based.  Note\n that these operations may execute in time proportional to the index value\n for some implementations (the LinkedList class, for\n example). Thus, iterating over the elements in a list is typically\n preferable to indexing through it if the caller does not know the\n implementation.\n\n The List interface provides a special iterator, called a\n ListIterator, that allows element insertion and replacement, and\n bidirectional access in addition to the normal operations that the\n Iterator interface provides.  A method is provided to obtain a\n list iterator that starts at a specified position in the list.\n\n The List interface provides two methods to search for a specified\n object.  From a performance standpoint, these methods should be used with\n caution.  In many implementations they will perform costly linear\n searches.\n\n The List interface provides two methods to efficiently insert and\n remove multiple elements at an arbitrary point in the list.\n\n Note: While it is permissible for lists to contain themselves as elements,\n extreme caution is advised: the equals and hashCode\n methods are no longer well defined on such a list.\n\n Some list implementations have restrictions on the elements that\n they may contain.  For example, some implementations prohibit null elements,\n and some have restrictions on the types of their elements.  Attempting to\n add an ineligible element throws an unchecked exception, typically\n NullPointerException or ClassCastException.  Attempting\n to query the presence of an ineligible element may throw an exception,\n or it may simply return false; some implementations will exhibit the former\n behavior and some will exhibit the latter.  More generally, attempting an\n operation on an ineligible element whose completion would not result in\n the insertion of an ineligible element into the list may throw an\n exception or it may succeed, at the option of the implementation.\n Such exceptions are marked as \"optional\" in the specification for this\n interface.\n\n Unmodifiable Lists\nThe List.of and\n List.copyOf static factory methods\n provide a convenient way to create unmodifiable lists. The List\n instances created by these methods have the following characteristics:\n\n \nThey are unmodifiable. Elements cannot\n be added, removed, or replaced. Calling any mutator method on the List\n will always cause UnsupportedOperationException to be thrown.\n However, if the contained elements are themselves mutable,\n this may cause the List's contents to appear to change.\n They disallow null elements. Attempts to create them with\n null elements result in NullPointerException.\n They are serializable if all elements are serializable.\n The order of elements in the list is the same as the order of the\n provided arguments, or of the elements in the provided array.\n They are value-based.\n Callers should make no assumptions about the identity of the returned instances.\n Factories are free to create new instances or reuse existing ones. Therefore,\n identity-sensitive operations on these instances (reference equality (==),\n identity hash code, and synchronization) are unreliable and should be avoided.\n They are serialized as specified on the\n Serialized Form\n page.\n \nThis interface is a member of the\n \n Java Collections Framework.\n\nSince:\n1.2\nSee Also:\nCollection, \nSet, \nArrayList, \nLinkedList, \nVector, \nArrays.asList(Object[]), \nCollections.nCopies(int, Object), \nCollections.EMPTY_LIST, \nAbstractList, \nAbstractSequentialList",
    "Optional": "Type Parameters:\nT - the type of value\n\n\npublic final class Optional<T>\nextends Object\nA container object which may or may not contain a non-null value.\n If a value is present, isPresent() returns true. If no\n value is present, the object is considered empty and\n isPresent() returns false.\n\n Additional methods that depend on the presence or absence of a contained\n value are provided, such as orElse()\n (returns a default value if no value is present) and\n ifPresent() (performs an\n action if a value is present).\n\n This is a value-based\n class; use of identity-sensitive operations (including reference equality\n (==), identity hash code, or synchronization) on instances of\n Optional may have unpredictable results and should be avoided.\n\nAPI Note:\nOptional is primarily intended for use as a method return type where\n there is a clear need to represent \"no result,\" and where using null\n is likely to cause errors. A variable whose type is Optional should\n never itself be null; it should always point to an Optional\n instance.\nSince:\n1.8",
    "Platform": "public final class Platform\nextends Object\nApplication platform support class.\n\nSince:\nJavaFX 2.0",
    "TextInputControl": "All Implemented Interfaces:\nStyleable, EventTarget, Skinnable\n\n\nDirect Known Subclasses:\nTextArea, TextField\n\n\n@DefaultProperty(\"text\")\npublic abstract class TextInputControl\nextends Control\nAbstract base class for text input controls.\n\nSince:\nJavaFX 2.0",
    "Clipboard": "Direct Known Subclasses:\nDragboard\n\n\npublic class Clipboard\nextends Object\nRepresents an operating system clipboard, on which data may be placed during, for\n example, cut, copy, and paste operations.\n \n To access the general system clipboard, use the following code:\n \n     Clipboard clipboard = Clipboard.getSystemClipboard();\n \n\n There is only ever one instance of the system clipboard in the application, so it is\n perfectly acceptable to stash a reference to it somewhere handy if you so choose.\n \n The Clipboard operates on the concept of having a single conceptual item on the\n clipboard at any one time -- though it may be placed on the clipboard in different\n formats. For example, the user might select text in an HTML editor and press the\n ctrl+c or cmd+c to copy it. In this case, the same text might be available on the\n clipboard both as HTML and as plain text. There are two copies of the data on the\n clipboard, but they both represent the same data.\n \n Content is specified on the Clipboard by using the setContent(java.util.Map<javafx.scene.input.DataFormat, java.lang.Object>)\n method. First, construct a ClipboardContent object, then invoke setContent. Every time\n setContent is called, any previous data on the clipboard is cleared and replaced with\n this new content.\n \n     final Clipboard clipboard = Clipboard.getSystemClipboard();\n     final ClipboardContent content = new ClipboardContent();\n     content.putString(\"Some text\");\n     content.putHtml(\"<b>Some</b> text\");\n     clipboard.setContent(content);\n \n\n The ClipboardContent class is simply a map with convenience methods for dealing\n with common data types added to a clipboard.\n \n Because multiple representations of the same data may exist on the clipboard, and because\n different applications have different capabilities for handling different content types,\n it is important to place as many data representations on the clipboard as is practical to\n facilitate external applications. Note that sometimes the operating system might be\n helpful in some cases and add multiple types for you. For example, the Mac might set the\n plain text string for you when you specify the RTF type. How and under what circumstances\n this occurs is outside the realm of this specification, consult your OS documentation.\n \n When reading data off the clipboard, it is important to look for the richest\n supported type first. For example, if I have a text document which supports embedding of\n images and media formats, when pasting content from the clipboard I should first check to\n see if the content can be represented as media or as an image. If not, then I might check\n for RTF or HTML or whatever rich text format is supported by my document type. If not,\n then I might just take a String.\n \n Or for example, if I have a plain text document, then I would simple get a String\n representation and use that, if available. I can check to see if the clipboard \"hasHtml\"\n or \"hasString\".\n \n     if (clipboard.hasString()) { ... }\n \n\n In addition to the common or built in types, you may put any arbitrary data onto the\n clipboard (assuming it is serializable).\n \n Content types are defined by the DataFormat objects.\n The DataFormat class defines an immutable object, and there are a number of static final\n fields for common DataFormat types. Of course application specific DataFormat types can also be\n declared and used. The following two methods are equivalent (and the second call\n will override the first!)\n \n     ClipboardContent content = new ClipboardContent();\n     content.putString(\"some text\");\n     content.put(DataFormat.PLAIN_TEXT, \"other text\");\n \n\n On embedded platforms that do not have their own windowing system, the\n Clipboard returned from Clipboard.getSystemClipboard() might not be\n accessible from outside the JavaFX application.\n\n\n If a security manager is present, the application must have the\n FXPermission \"accessClipboard\" in order for the\n Clipboard returned from Clipboard.getSystemClipboard() to be\n accessible from outside the JavaFX application. For compatibility with\n previous versions of the JDK the equivalent AWTPermission\n \"accessClipboard\" will also allow the FX clipboard to be accessible from\n outside the JavaFX application.\n \n\n If the application lacks permission or if the platform doesn't support\n a shared clipboard, the clipboard\n returned by Clipboard.getSystemClipboard() can be used for exchange of data\n between different parts of one JavaFX application but cannot be used to\n exchange data between multiple applications.\n \n\nSince:\nJavaFX 2.0",
    "ClipboardContent": "All Implemented Interfaces:\nSerializable, Cloneable, Map<DataFormat,Object>\n\n\npublic class ClipboardContent\nextends HashMap<DataFormat,Object>\nData container for Clipboard data. It can hold multiple data in\n several data formats.\n\nSince:\nJavaFX 2.0\nSee Also:\nSerialized Form",
    "DataFormat": "public class DataFormat\nextends Object\nData format identifier used as means\n of identifying the data stored on a clipboard/dragboard.\n\nSince:\nJavaFX 2.0",
    "MouseButton": "All Implemented Interfaces:\nSerializable, Comparable<MouseButton>\n\n\npublic enum MouseButton\nextends Enum<MouseButton>\nMapping for Button Names\n\nSince:\nJavaFX 2.0",
    "AllowedToUseAwt": "Java Components page\nLooking for a different release? Other releases",
    "BibEntryWriter": "Java Components page\nLooking for a different release? Other releases",
    "FieldWriter": "Java Components page\nLooking for a different release? Other releases",
    "BibDatabaseMode": "Java Components page\nLooking for a different release? Other releases",
    "BibEntry": "Java Components page\nLooking for a different release? Other releases",
    "PreferencesService": "Java Components page\nLooking for a different release? Other releases",
    "Logger": "Java Components page\nLooking for a different release? Other releases",
    "LoggerFactory": "Java Components page\nLooking for a different release? Other releases"
}