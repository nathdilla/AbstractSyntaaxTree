{
    "Scanner": "All Implemented Interfaces:\nCloseable, AutoCloseable, Iterator<String>\n\n\npublic final class Scanner\nextends Object\nimplements Iterator<String>, Closeable\nA simple text scanner which can parse primitive types and strings using\n regular expressions.\n\n A Scanner breaks its input into tokens using a\n delimiter pattern, which by default matches whitespace. The resulting\n tokens may then be converted into values of different types using the\n various next methods.\n\n For example, this code allows a user to read a number from\n System.in:\n \n     Scanner sc = new Scanner(System.in);\n     int i = sc.nextInt();\n \nAs another example, this code allows long types to be\n assigned from entries in a file myNumbers:\n \n      Scanner sc = new Scanner(new File(\"myNumbers\"));\n      while (sc.hasNextLong()) {\n          long aLong = sc.nextLong();\n      }\n \nThe scanner can also use delimiters other than whitespace. This\n example reads several items in from a string:\n \n     String input = \"1 fish 2 fish red fish blue fish\";\n     Scanner s = new Scanner(input).useDelimiter(\"\\\\s*fish\\\\s*\");\n     System.out.println(s.nextInt());\n     System.out.println(s.nextInt());\n     System.out.println(s.next());\n     System.out.println(s.next());\n     s.close();\n \n\n prints the following output:\n \n     1\n     2\n     red\n     blue\n \nThe same output can be generated with this code, which uses a regular\n expression to parse all four tokens at once:\n \n     String input = \"1 fish 2 fish red fish blue fish\";\n     Scanner s = new Scanner(input);\n     s.findInLine(\"(\\\\d+) fish (\\\\d+) fish (\\\\w+) fish (\\\\w+)\");\n     MatchResult result = s.match();\n     for (int i=1; i<=result.groupCount(); i++)\n         System.out.println(result.group(i));\n     s.close();\n \nThe default whitespace delimiter used\n by a scanner is as recognized by Character.isWhitespace(). The reset()\n method will reset the value of the scanner's delimiter to the default\n whitespace delimiter regardless of whether it was previously changed.\n\n A scanning operation may block waiting for input.\n\n The next() and hasNext() methods and their\n companion methods (such as nextInt() and\n hasNextInt()) first skip any input that matches the delimiter\n pattern, and then attempt to return the next token. Both hasNext()\n and next() methods may block waiting for further input.  Whether a\n hasNext() method blocks has no connection to whether or not its\n associated next() method will block. The tokens() method\n may also block waiting for input.\n\n The findInLine(),\n findWithinHorizon(),\n skip(), and findAll()\n methods operate independently of the delimiter pattern. These methods will\n attempt to match the specified pattern with no regard to delimiters in the\n input and thus can be used in special circumstances where delimiters are\n not relevant. These methods may block waiting for more input.\n\n When a scanner throws an InputMismatchException, the scanner\n will not pass the token that caused the exception, so that it may be\n retrieved or skipped via some other method.\n\n Depending upon the type of delimiting pattern, empty tokens may be\n returned. For example, the pattern \"\\\\s+\" will return no empty\n tokens since it matches multiple instances of the delimiter. The delimiting\n pattern \"\\\\s\" could return empty tokens since it only passes one\n space at a time.\n\n  A scanner can read text from any object which implements the Readable interface.  If an invocation of the underlying\n readable's read() method throws an IOException then the scanner assumes that the end of the input\n has been reached.  The most recent IOException thrown by the\n underlying readable can be retrieved via the ioException() method.\n\n When a Scanner is closed, it will close its input source\n if the source implements the Closeable interface.\n\n A Scanner is not safe for multithreaded use without\n external synchronization.\n\n Unless otherwise mentioned, passing a null parameter into\n any method of a Scanner will cause a\n NullPointerException to be thrown.\n\n A scanner will default to interpreting numbers as decimal unless a\n different radix has been set by using the useRadix(int) method. The\n reset() method will reset the value of the scanner's radix to\n 10 regardless of whether it was previously changed.\n\n  Localized numbers \n An instance of this class is capable of scanning numbers in the standard\n formats as well as in the formats of the scanner's locale. A scanner's\n initial locale is the value returned by the Locale.getDefault(Locale.Category.FORMAT) method; it may be changed via the useLocale() method. The reset() method will reset the value of the\n scanner's locale to the initial locale regardless of whether it was\n previously changed.\n\n The localized formats are defined in terms of the following parameters,\n which for a particular locale are taken from that locale's DecimalFormat object, df, and its and\n DecimalFormatSymbols object,\n dfs.\n\n \nLocalGroupSeparator\u00a0\u00a0\nThe character used to separate thousands groups,\n         i.e.,\u00a0dfs.getGroupingSeparator()\nLocalDecimalSeparator\u00a0\u00a0\nThe character used for the decimal point,\n     i.e.,\u00a0dfs.getDecimalSeparator()\nLocalPositivePrefix\u00a0\u00a0\nThe string that appears before a positive number (may\n         be empty), i.e.,\u00a0df.getPositivePrefix()\nLocalPositiveSuffix\u00a0\u00a0\nThe string that appears after a positive number (may be\n         empty), i.e.,\u00a0df.getPositiveSuffix()\nLocalNegativePrefix\u00a0\u00a0\nThe string that appears before a negative number (may\n         be empty), i.e.,\u00a0df.getNegativePrefix()\nLocalNegativeSuffix\u00a0\u00a0\nThe string that appears after a negative number (may be\n         empty), i.e.,\u00a0df.getNegativeSuffix()\nLocalNaN\u00a0\u00a0\nThe string that represents not-a-number for\n         floating-point values,\n         i.e.,\u00a0dfs.getNaN()\nLocalInfinity\u00a0\u00a0\nThe string that represents infinity for floating-point\n         values, i.e.,\u00a0dfs.getInfinity()\n\n Number syntax \n The strings that can be parsed as numbers by an instance of this class\n are specified in terms of the following regular-expression grammar, where\n Rmax is the highest digit in the radix being used (for example, Rmax is 9 in base 10).\n\n \nNonAsciiDigit:\n       A non-ASCII character c for which\n            Character.isDigit(c)\n                        returns\u00a0true\n\n   Non0Digit:\n       [1-Rmax] | NonASCIIDigit\nDigit:\n       [0-Rmax] | NonASCIIDigit\nGroupedNumeral:\n       (\u00a0Non0Digit\nDigit?\n                   Digit?\n\u00a0\u00a0\u00a0\u00a0(\u00a0LocalGroupSeparator\nDigit\nDigit\nDigit )+ )\nNumeral:\n       ( ( Digit+ )\n               | GroupedNumeral )\nInteger:\n( [-+]? ( Numeral\n                               ) )\n| LocalPositivePrefix Numeral\nLocalPositiveSuffix\n| LocalNegativePrefix Numeral\nLocalNegativeSuffix\nDecimalNumeral:\n       Numeral\n| Numeral\nLocalDecimalSeparator\nDigit*\n| LocalDecimalSeparator\nDigit+\nExponent:\n       ( [eE] [+-]? Digit+ )\nDecimal:\n( [-+]? DecimalNumeral\nExponent? )\n| LocalPositivePrefix\nDecimalNumeral\nLocalPositiveSuffix\nExponent?\n| LocalNegativePrefix\nDecimalNumeral\nLocalNegativeSuffix\nExponent?\nHexFloat:\n       [-+]? 0[xX][0-9a-fA-F]*\\.[0-9a-fA-F]+\n                 ([pP][-+]?[0-9]+)?\nNonNumber:\n       NaN\n                          | LocalNan\n                          | Infinity\n                          | LocalInfinity\nSignedNonNumber:\n       ( [-+]? NonNumber )\n| LocalPositivePrefix\nNonNumber\nLocalPositiveSuffix\n| LocalNegativePrefix\nNonNumber\nLocalNegativeSuffix\nFloat:\n       Decimal\n| HexFloat\n| SignedNonNumber\n\nWhitespace is not significant in the above regular expressions.\n\nSince:\n1.5"
}