{
    "HashSet": "Type Parameters:\nE - the type of elements maintained by this set\n\n\nAll Implemented Interfaces:\nSerializable, Cloneable, Iterable<E>, Collection<E>, Set<E>\n\n\nDirect Known Subclasses:\nJobStateReasons, LinkedHashSet\n\n\npublic class HashSet<E>\nextends AbstractSet<E>\nimplements Set<E>, Cloneable, Serializable\nThis class implements the Set interface, backed by a hash table\n (actually a HashMap instance).  It makes no guarantees as to the\n iteration order of the set; in particular, it does not guarantee that the\n order will remain constant over time.  This class permits the null\n element.\n\n This class offers constant time performance for the basic operations\n (add, remove, contains and size),\n assuming the hash function disperses the elements properly among the\n buckets.  Iterating over this set requires time proportional to the sum of\n the HashSet instance's size (the number of elements) plus the\n \"capacity\" of the backing HashMap instance (the number of\n buckets).  Thus, it's very important not to set the initial capacity too\n high (or the load factor too low) if iteration performance is important.\n\n Note that this implementation is not synchronized.\n If multiple threads access a hash set concurrently, and at least one of\n the threads modifies the set, it must be synchronized externally.\n This is typically accomplished by synchronizing on some object that\n naturally encapsulates the set.\n\n If no such object exists, the set should be \"wrapped\" using the\n Collections.synchronizedSet\n method.  This is best done at creation time, to prevent accidental\n unsynchronized access to the set:\n   Set s = Collections.synchronizedSet(new HashSet(...));\nThe iterators returned by this class's iterator method are\n fail-fast: if the set is modified at any time after the iterator is\n created, in any way except through the iterator's own remove\n method, the Iterator throws a ConcurrentModificationException.\n Thus, in the face of concurrent modification, the iterator fails quickly\n and cleanly, rather than risking arbitrary, non-deterministic behavior at\n an undetermined time in the future.\n\n Note that the fail-fast behavior of an iterator cannot be guaranteed\n as it is, generally speaking, impossible to make any hard guarantees in the\n presence of unsynchronized concurrent modification.  Fail-fast iterators\n throw ConcurrentModificationException on a best-effort basis.\n Therefore, it would be wrong to write a program that depended on this\n exception for its correctness: the fail-fast behavior of iterators\n should be used only to detect bugs.\nThis class is a member of the\n \n Java Collections Framework.\n\nSince:\n1.2\nSee Also:\nCollection, \nSet, \nTreeSet, \nHashMap, \nSerialized Form",
    "Set": "Type Parameters:\nE - the type of elements maintained by this set\n\n\nAll Superinterfaces:\nCollection<E>, Iterable<E>\n\n\nAll Known Subinterfaces:\nEventSet, NavigableSet<E>, ObservableSet<E>, ObservableSetValue<E>, SortedSet<E>, WritableSetValue<E>\n\n\nAll Known Implementing Classes:\nAbstractSet, ConcurrentHashMap.KeySetView, ConcurrentSkipListSet, CopyOnWriteArraySet, EnumSet, HashSet, JobStateReasons, LinkedHashSet, ReadOnlySetProperty, ReadOnlySetPropertyBase, ReadOnlySetWrapper, SetBinding, SetExpression, SetProperty, SetPropertyBase, SimpleSetProperty, TreeSet\n\n\npublic interface Set<E>\nextends Collection<E>\nA collection that contains no duplicate elements.  More formally, sets\n contain no pair of elements e1 and e2 such that\n e1.equals(e2), and at most one null element.  As implied by\n its name, this interface models the mathematical set abstraction.\n\n The Set interface places additional stipulations, beyond those\n inherited from the Collection interface, on the contracts of all\n constructors and on the contracts of the add, equals and\n hashCode methods.  Declarations for other inherited methods are\n also included here for convenience.  (The specifications accompanying these\n declarations have been tailored to the Set interface, but they do\n not contain any additional stipulations.)\n\n The additional stipulation on constructors is, not surprisingly,\n that all constructors must create a set that contains no duplicate elements\n (as defined above).\n\n Note: Great care must be exercised if mutable objects are used as set\n elements.  The behavior of a set is not specified if the value of an object\n is changed in a manner that affects equals comparisons while the\n object is an element in the set.  A special case of this prohibition is\n that it is not permissible for a set to contain itself as an element.\n\n Some set implementations have restrictions on the elements that\n they may contain.  For example, some implementations prohibit null elements,\n and some have restrictions on the types of their elements.  Attempting to\n add an ineligible element throws an unchecked exception, typically\n NullPointerException or ClassCastException.  Attempting\n to query the presence of an ineligible element may throw an exception,\n or it may simply return false; some implementations will exhibit the former\n behavior and some will exhibit the latter.  More generally, attempting an\n operation on an ineligible element whose completion would not result in\n the insertion of an ineligible element into the set may throw an\n exception or it may succeed, at the option of the implementation.\n Such exceptions are marked as \"optional\" in the specification for this\n interface.\n\n Unmodifiable Sets\nThe Set.of and\n Set.copyOf static factory methods\n provide a convenient way to create unmodifiable sets. The Set\n instances created by these methods have the following characteristics:\n\n \nThey are unmodifiable. Elements cannot\n be added or removed. Calling any mutator method on the Set\n will always cause UnsupportedOperationException to be thrown.\n However, if the contained elements are themselves mutable, this may cause the\n Set to behave inconsistently or its contents to appear to change.\n They disallow null elements. Attempts to create them with\n null elements result in NullPointerException.\n They are serializable if all elements are serializable.\n They reject duplicate elements at creation time. Duplicate elements\n passed to a static factory method result in IllegalArgumentException.\n The iteration order of set elements is unspecified and is subject to change.\n They are value-based.\n Callers should make no assumptions about the identity of the returned instances.\n Factories are free to create new instances or reuse existing ones. Therefore,\n identity-sensitive operations on these instances (reference equality (==),\n identity hash code, and synchronization) are unreliable and should be avoided.\n They are serialized as specified on the\n Serialized Form\n page.\n \nThis interface is a member of the\n \n Java Collections Framework.\n\nSince:\n1.2\nSee Also:\nCollection, \nList, \nSortedSet, \nHashSet, \nTreeSet, \nAbstractSet, \nCollections.singleton(java.lang.Object), \nCollections.EMPTY_SET",
    "ArrayBlockingQueue": "Type Parameters:\nE - the type of elements held in this queue\n\n\nAll Implemented Interfaces:\nSerializable, Iterable<E>, Collection<E>, BlockingQueue<E>, Queue<E>\n\n\npublic class ArrayBlockingQueue<E>\nextends AbstractQueue<E>\nimplements BlockingQueue<E>, Serializable\nA bounded blocking queue backed by an\n array.  This queue orders elements FIFO (first-in-first-out).  The\n head of the queue is that element that has been on the\n queue the longest time.  The tail of the queue is that\n element that has been on the queue the shortest time. New elements\n are inserted at the tail of the queue, and the queue retrieval\n operations obtain elements at the head of the queue.\n\n This is a classic \"bounded buffer\", in which a\n fixed-sized array holds elements inserted by producers and\n extracted by consumers.  Once created, the capacity cannot be\n changed.  Attempts to put an element into a full queue\n will result in the operation blocking; attempts to take an\n element from an empty queue will similarly block.\n\n This class supports an optional fairness policy for ordering\n waiting producer and consumer threads.  By default, this ordering\n is not guaranteed. However, a queue constructed with fairness set\n to true grants threads access in FIFO order. Fairness\n generally decreases throughput but reduces variability and avoids\n starvation.\n\n This class and its iterator implement all of the optional\n methods of the Collection and Iterator interfaces.\n\n This class is a member of the\n \n Java Collections Framework.\n\nSince:\n1.5\nSee Also:\nSerialized Form",
    "BlockingQueue": "Type Parameters:\nE - the type of elements held in this queue\n\n\nAll Superinterfaces:\nCollection<E>, Iterable<E>, Queue<E>\n\n\nAll Known Subinterfaces:\nBlockingDeque<E>, TransferQueue<E>\n\n\nAll Known Implementing Classes:\nArrayBlockingQueue, DelayQueue, LinkedBlockingDeque, LinkedBlockingQueue, LinkedTransferQueue, PriorityBlockingQueue, SynchronousQueue\n\n\npublic interface BlockingQueue<E>\nextends Queue<E>\nA Queue that additionally supports operations that wait for\n the queue to become non-empty when retrieving an element, and wait\n for space to become available in the queue when storing an element.\n\n BlockingQueue methods come in four forms, with different ways\n of handling operations that cannot be satisfied immediately, but may be\n satisfied at some point in the future:\n one throws an exception, the second returns a special value (either\n null or false, depending on the operation), the third\n blocks the current thread indefinitely until the operation can succeed,\n and the fourth blocks for only a given maximum time limit before giving\n up.  These methods are summarized in the following table:\n\n \nSummary of BlockingQueue methods\n\n\nThrows exception\nSpecial value\nBlocks\nTimes out\n\n\nInsert\nadd(e)\noffer(e)\nput(e)\noffer(e, time, unit)\n\n\nRemove\nremove()\npoll()\ntake()\npoll(time, unit)\n\n\nExamine\nelement()\npeek()\nnot applicable\nnot applicable\n\n\nA BlockingQueue does not accept null elements.\n Implementations throw NullPointerException on attempts\n to add, put or offer a null.  A\n null is used as a sentinel value to indicate failure of\n poll operations.\n\n A BlockingQueue may be capacity bounded. At any given\n time it may have a remainingCapacity beyond which no\n additional elements can be put without blocking.\n A BlockingQueue without any intrinsic capacity constraints always\n reports a remaining capacity of Integer.MAX_VALUE.\n\n BlockingQueue implementations are designed to be used\n primarily for producer-consumer queues, but additionally support\n the Collection interface.  So, for example, it is\n possible to remove an arbitrary element from a queue using\n remove(x). However, such operations are in general\n not performed very efficiently, and are intended for only\n occasional use, such as when a queued message is cancelled.\n\n BlockingQueue implementations are thread-safe.  All\n queuing methods achieve their effects atomically using internal\n locks or other forms of concurrency control. However, the\n bulk Collection operations addAll,\n containsAll, retainAll and removeAll are\n not necessarily performed atomically unless specified\n otherwise in an implementation. So it is possible, for example, for\n addAll(c) to fail (throwing an exception) after adding\n only some of the elements in c.\n\n A BlockingQueue does not intrinsically support\n any kind of \"close\" or \"shutdown\" operation to\n indicate that no more items will be added.  The needs and usage of\n such features tend to be implementation-dependent. For example, a\n common tactic is for producers to insert special\n end-of-stream or poison objects, that are\n interpreted accordingly when taken by consumers.\n\n \n Usage example, based on a typical producer-consumer scenario.\n Note that a BlockingQueue can safely be used with multiple\n producers and multiple consumers.\n  \n class Producer implements Runnable {\n   private final BlockingQueue queue;\n   Producer(BlockingQueue q) { queue = q; }\n   public void run() {\n     try {\n       while (true) { queue.put(produce()); }\n     } catch (InterruptedException ex) { ... handle ...}\n   }\n   Object produce() { ... }\n }\n\n class Consumer implements Runnable {\n   private final BlockingQueue queue;\n   Consumer(BlockingQueue q) { queue = q; }\n   public void run() {\n     try {\n       while (true) { consume(queue.take()); }\n     } catch (InterruptedException ex) { ... handle ...}\n   }\n   void consume(Object x) { ... }\n }\n\n class Setup {\n   void main() {\n     BlockingQueue q = new SomeQueueImplementation();\n     Producer p = new Producer(q);\n     Consumer c1 = new Consumer(q);\n     Consumer c2 = new Consumer(q);\n     new Thread(p).start();\n     new Thread(c1).start();\n     new Thread(c2).start();\n   }\n }\nMemory consistency effects: As with other concurrent\n collections, actions in a thread prior to placing an object into a\n BlockingQueue\nhappen-before\n actions subsequent to the access or removal of that element from\n the BlockingQueue in another thread.\n\n This interface is a member of the\n \n Java Collections Framework.\n\nSince:\n1.5",
    "ExecutorService": "All Superinterfaces:\nExecutor\n\n\nAll Known Subinterfaces:\nScheduledExecutorService\n\n\nAll Known Implementing Classes:\nAbstractExecutorService, ForkJoinPool, ScheduledThreadPoolExecutor, ThreadPoolExecutor\n\n\npublic interface ExecutorService\nextends Executor\nAn Executor that provides methods to manage termination and\n methods that can produce a Future for tracking progress of\n one or more asynchronous tasks.\n\n An ExecutorService can be shut down, which will cause\n it to reject new tasks.  Two different methods are provided for\n shutting down an ExecutorService. The shutdown()\n method will allow previously submitted tasks to execute before\n terminating, while the shutdownNow() method prevents waiting\n tasks from starting and attempts to stop currently executing tasks.\n Upon termination, an executor has no tasks actively executing, no\n tasks awaiting execution, and no new tasks can be submitted.  An\n unused ExecutorService should be shut down to allow\n reclamation of its resources.\n\n Method submit extends base method Executor.execute(Runnable) by creating and returning a Future\n that can be used to cancel execution and/or wait for completion.\n Methods invokeAny and invokeAll perform the most\n commonly useful forms of bulk execution, executing a collection of\n tasks and then waiting for at least one, or all, to\n complete. (Class ExecutorCompletionService can be used to\n write customized variants of these methods.)\n\n The Executors class provides factory methods for the\n executor services provided in this package.\n\n Usage Examples\n\n Here is a sketch of a network service in which threads in a thread\n pool service incoming requests. It uses the preconfigured Executors.newFixedThreadPool(int) factory method:\n\n  \n class NetworkService implements Runnable {\n   private final ServerSocket serverSocket;\n   private final ExecutorService pool;\n\n   public NetworkService(int port, int poolSize)\n       throws IOException {\n     serverSocket = new ServerSocket(port);\n     pool = Executors.newFixedThreadPool(poolSize);\n   }\n\n   public void run() { // run the service\n     try {\n       for (;;) {\n         pool.execute(new Handler(serverSocket.accept()));\n       }\n     } catch (IOException ex) {\n       pool.shutdown();\n     }\n   }\n }\n\n class Handler implements Runnable {\n   private final Socket socket;\n   Handler(Socket socket) { this.socket = socket; }\n   public void run() {\n     // read and service request on socket\n   }\n }\n\n The following method shuts down an ExecutorService in two phases,\n first by calling shutdown to reject incoming tasks, and then\n calling shutdownNow, if necessary, to cancel any lingering tasks:\n\n  \n void shutdownAndAwaitTermination(ExecutorService pool) {\n   pool.shutdown(); // Disable new tasks from being submitted\n   try {\n     // Wait a while for existing tasks to terminate\n     if (!pool.awaitTermination(60, TimeUnit.SECONDS)) {\n       pool.shutdownNow(); // Cancel currently executing tasks\n       // Wait a while for tasks to respond to being cancelled\n       if (!pool.awaitTermination(60, TimeUnit.SECONDS))\n           System.err.println(\"Pool did not terminate\");\n     }\n   } catch (InterruptedException ie) {\n     // (Re-)Cancel if current thread also interrupted\n     pool.shutdownNow();\n     // Preserve interrupt status\n     Thread.currentThread().interrupt();\n   }\n }\nMemory consistency effects: Actions in a thread prior to the\n submission of a Runnable or Callable task to an\n ExecutorService\nhappen-before\n any actions taken by that task, which in turn happen-before the\n result is retrieved via Future.get().\n\nSince:\n1.5",
    "RejectedExecutionException": "All Implemented Interfaces:\nSerializable\n\n\npublic class RejectedExecutionException\nextends RuntimeException\nException thrown by an Executor when a task cannot be\n accepted for execution.\n\nSince:\n1.5\nSee Also:\nSerialized Form",
    "ThreadPoolExecutor": "All Implemented Interfaces:\nExecutor, ExecutorService\n\n\nDirect Known Subclasses:\nScheduledThreadPoolExecutor\n\n\npublic class ThreadPoolExecutor\nextends AbstractExecutorService\nAn ExecutorService that executes each submitted task using\n one of possibly several pooled threads, normally configured\n using Executors factory methods.\n\n Thread pools address two different problems: they usually\n provide improved performance when executing large numbers of\n asynchronous tasks, due to reduced per-task invocation overhead,\n and they provide a means of bounding and managing the resources,\n including threads, consumed when executing a collection of tasks.\n Each ThreadPoolExecutor also maintains some basic\n statistics, such as the number of completed tasks.\n\n To be useful across a wide range of contexts, this class\n provides many adjustable parameters and extensibility\n hooks. However, programmers are urged to use the more convenient\n Executors factory methods Executors.newCachedThreadPool() (unbounded thread pool, with\n automatic thread reclamation), Executors.newFixedThreadPool(int)\n (fixed size thread pool) and Executors.newSingleThreadExecutor() (single background thread), that\n preconfigure settings for the most common usage\n scenarios. Otherwise, use the following guide when manually\n configuring and tuning this class:\n\n \nCore and maximum pool sizes\nA ThreadPoolExecutor will automatically adjust the\n pool size (see getPoolSize())\n according to the bounds set by\n corePoolSize (see getCorePoolSize()) and\n maximumPoolSize (see getMaximumPoolSize()).\n\n When a new task is submitted in method execute(Runnable),\n if fewer than corePoolSize threads are running, a new thread is\n created to handle the request, even if other worker threads are\n idle.  Else if fewer than maximumPoolSize threads are running, a\n new thread will be created to handle the request only if the queue\n is full.  By setting corePoolSize and maximumPoolSize the same, you\n create a fixed-size thread pool. By setting maximumPoolSize to an\n essentially unbounded value such as Integer.MAX_VALUE, you\n allow the pool to accommodate an arbitrary number of concurrent\n tasks. Most typically, core and maximum pool sizes are set only\n upon construction, but they may also be changed dynamically using\n setCorePoolSize(int) and setMaximumPoolSize(int). \nOn-demand construction\nBy default, even core threads are initially created and\n started only when new tasks arrive, but this can be overridden\n dynamically using method prestartCoreThread() or prestartAllCoreThreads().  You probably want to prestart threads if\n you construct the pool with a non-empty queue. \nCreating new threads\nNew threads are created using a ThreadFactory.  If not\n otherwise specified, a Executors.defaultThreadFactory() is\n used, that creates threads to all be in the same ThreadGroup and with the same NORM_PRIORITY priority and\n non-daemon status. By supplying a different ThreadFactory, you can\n alter the thread's name, thread group, priority, daemon status,\n etc. If a ThreadFactory fails to create a thread when asked\n by returning null from newThread, the executor will\n continue, but might not be able to execute any tasks. Threads\n should possess the \"modifyThread\" RuntimePermission. If\n worker threads or other threads using the pool do not possess this\n permission, service may be degraded: configuration changes may not\n take effect in a timely manner, and a shutdown pool may remain in a\n state in which termination is possible but not completed.\nKeep-alive times\nIf the pool currently has more than corePoolSize threads,\n excess threads will be terminated if they have been idle for more\n than the keepAliveTime (see getKeepAliveTime(TimeUnit)).\n This provides a means of reducing resource consumption when the\n pool is not being actively used. If the pool becomes more active\n later, new threads will be constructed. This parameter can also be\n changed dynamically using method setKeepAliveTime(long,\n TimeUnit).  Using a value of Long.MAX_VALUE TimeUnit.NANOSECONDS effectively disables idle threads from ever\n terminating prior to shut down. By default, the keep-alive policy\n applies only when there are more than corePoolSize threads, but\n method allowCoreThreadTimeOut(boolean) can be used to\n apply this time-out policy to core threads as well, so long as the\n keepAliveTime value is non-zero. \nQueuing\nAny BlockingQueue may be used to transfer and hold\n submitted tasks.  The use of this queue interacts with pool sizing:\n\n \nIf fewer than corePoolSize threads are running, the Executor\n always prefers adding a new thread\n rather than queuing.\n\n If corePoolSize or more threads are running, the Executor\n always prefers queuing a request rather than adding a new\n thread.\n\n If a request cannot be queued, a new thread is created unless\n this would exceed maximumPoolSize, in which case, the task will be\n rejected.\n\n \n\n There are three general strategies for queuing:\n \n Direct handoffs. A good default choice for a work\n queue is a SynchronousQueue that hands off tasks to threads\n without otherwise holding them. Here, an attempt to queue a task\n will fail if no threads are immediately available to run it, so a\n new thread will be constructed. This policy avoids lockups when\n handling sets of requests that might have internal dependencies.\n Direct handoffs generally require unbounded maximumPoolSizes to\n avoid rejection of new submitted tasks. This in turn admits the\n possibility of unbounded thread growth when commands continue to\n arrive on average faster than they can be processed.\n\n  Unbounded queues. Using an unbounded queue (for\n example a LinkedBlockingQueue without a predefined\n capacity) will cause new tasks to wait in the queue when all\n corePoolSize threads are busy. Thus, no more than corePoolSize\n threads will ever be created. (And the value of the maximumPoolSize\n therefore doesn't have any effect.)  This may be appropriate when\n each task is completely independent of others, so tasks cannot\n affect each others execution; for example, in a web page server.\n While this style of queuing can be useful in smoothing out\n transient bursts of requests, it admits the possibility of\n unbounded work queue growth when commands continue to arrive on\n average faster than they can be processed.\n\n Bounded queues. A bounded queue (for example, an\n ArrayBlockingQueue) helps prevent resource exhaustion when\n used with finite maximumPoolSizes, but can be more difficult to\n tune and control.  Queue sizes and maximum pool sizes may be traded\n off for each other: Using large queues and small pools minimizes\n CPU usage, OS resources, and context-switching overhead, but can\n lead to artificially low throughput.  If tasks frequently block (for\n example if they are I/O bound), a system may be able to schedule\n time for more threads than you otherwise allow. Use of small queues\n generally requires larger pool sizes, which keeps CPUs busier but\n may encounter unacceptable scheduling overhead, which also\n decreases throughput.\n\n \n\nRejected tasks\nNew tasks submitted in method execute(Runnable) will be\n rejected when the Executor has been shut down, and also when\n the Executor uses finite bounds for both maximum threads and work queue\n capacity, and is saturated.  In either case, the execute method\n invokes the RejectedExecutionHandler.rejectedExecution(Runnable, ThreadPoolExecutor)\n method of its RejectedExecutionHandler.  Four predefined handler\n policies are provided:\n\n \nIn the default ThreadPoolExecutor.AbortPolicy, the handler\n throws a runtime RejectedExecutionException upon rejection.\n\n In ThreadPoolExecutor.CallerRunsPolicy, the thread\n that invokes execute itself runs the task. This provides a\n simple feedback control mechanism that will slow down the rate that\n new tasks are submitted.\n\n In ThreadPoolExecutor.DiscardPolicy, a task that\n cannot be executed is simply dropped.\n\n In ThreadPoolExecutor.DiscardOldestPolicy, if the\n executor is not shut down, the task at the head of the work queue\n is dropped, and then execution is retried (which can fail again,\n causing this to be repeated.)\n\n \n\n It is possible to define and use other kinds of RejectedExecutionHandler classes. Doing so requires some care\n especially when policies are designed to work only under particular\n capacity or queuing policies. \nHook methods\nThis class provides protected overridable\n beforeExecute(Thread, Runnable) and\n afterExecute(Runnable, Throwable) methods that are called\n before and after execution of each task.  These can be used to\n manipulate the execution environment; for example, reinitializing\n ThreadLocals, gathering statistics, or adding log entries.\n Additionally, method terminated() can be overridden to perform\n any special processing that needs to be done once the Executor has\n fully terminated.\n\n If hook, callback, or BlockingQueue methods throw exceptions,\n internal worker threads may in turn fail, abruptly terminate, and\n possibly be replaced.\nQueue maintenance\nMethod getQueue() allows access to the work queue\n for purposes of monitoring and debugging.  Use of this method for\n any other purpose is strongly discouraged.  Two supplied methods,\n remove(Runnable) and purge() are available to\n assist in storage reclamation when large numbers of queued tasks\n become cancelled.\nFinalization\nA pool that is no longer referenced in a program AND\n has no remaining threads will be shutdown automatically. If\n you would like to ensure that unreferenced pools are reclaimed even\n if users forget to call shutdown(), then you must arrange\n that unused threads eventually die, by setting appropriate\n keep-alive times, using a lower bound of zero core threads and/or\n setting allowCoreThreadTimeOut(boolean).  \n\nExtension example. Most extensions of this class\n override one or more of the protected hook methods. For example,\n here is a subclass that adds a simple pause/resume feature:\n\n  \n class PausableThreadPoolExecutor extends ThreadPoolExecutor {\n   private boolean isPaused;\n   private ReentrantLock pauseLock = new ReentrantLock();\n   private Condition unpaused = pauseLock.newCondition();\n\n   public PausableThreadPoolExecutor(...) { super(...); }\n\n   protected void beforeExecute(Thread t, Runnable r) {\n     super.beforeExecute(t, r);\n     pauseLock.lock();\n     try {\n       while (isPaused) unpaused.await();\n     } catch (InterruptedException ie) {\n       t.interrupt();\n     } finally {\n       pauseLock.unlock();\n     }\n   }\n\n   public void pause() {\n     pauseLock.lock();\n     try {\n       isPaused = true;\n     } finally {\n       pauseLock.unlock();\n     }\n   }\n\n   public void resume() {\n     pauseLock.lock();\n     try {\n       isPaused = false;\n       unpaused.signalAll();\n     } finally {\n       pauseLock.unlock();\n     }\n   }\n }\n\nSince:\n1.5",
    "TimeUnit": "All Implemented Interfaces:\nSerializable, Comparable<TimeUnit>\n\n\npublic enum TimeUnit\nextends Enum<TimeUnit>\nA TimeUnit represents time durations at a given unit of\n granularity and provides utility methods to convert across units,\n and to perform timing and delay operations in these units.  A\n TimeUnit does not maintain time information, but only\n helps organize and use time representations that may be maintained\n separately across various contexts.  A nanosecond is defined as one\n thousandth of a microsecond, a microsecond as one thousandth of a\n millisecond, a millisecond as one thousandth of a second, a minute\n as sixty seconds, an hour as sixty minutes, and a day as twenty four\n hours.\n\n A TimeUnit is mainly used to inform time-based methods\n how a given timing parameter should be interpreted. For example,\n the following code will timeout in 50 milliseconds if the lock is not available:\n\n  \n Lock lock = ...;\n if (lock.tryLock(50L, TimeUnit.MILLISECONDS)) ...\n\n while this code will timeout in 50 seconds:\n  \n Lock lock = ...;\n if (lock.tryLock(50L, TimeUnit.SECONDS)) ...\n\n Note however, that there is no guarantee that a particular timeout\n implementation will be able to notice the passage of time at the\n same granularity as the given TimeUnit.\n\nSince:\n1.5",
    "CoarseChangeFilter": "Java Components page\nLooking for a different release? Other releases",
    "BibDatabaseContext": "Java Components page\nLooking for a different release? Other releases",
    "AutosaveEvent": "Java Components page\nLooking for a different release? Other releases",
    "BibDatabaseContextChangedEvent": "Java Components page\nLooking for a different release? Other releases",
    "EventBus": "Java Components page\nLooking for a different release? Other releases",
    "Subscribe": "Java Components page\nLooking for a different release? Other releases",
    "Logger": "Java Components page\nLooking for a different release? Other releases",
    "LoggerFactory": "Java Components page\nLooking for a different release? Other releases"
}