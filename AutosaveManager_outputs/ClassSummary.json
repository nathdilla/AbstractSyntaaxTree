{"HashSet": "Type Parameters:\nE - the type of elements maintained by this set\n\n\nAll Implemented Interfaces:\nSerializable, Cloneable, Iterable<E>, Collection<E>, Set<E>\n\n\nDirect Known Subclasses:\nJobStateReasons, LinkedHashSet\n\n\npublic class HashSet<E>\nextends AbstractSet<E>\nimplements Set<E>, Cloneable, Serializable\nThis class implements the Set interface, backed by a hash table\n (actually a HashMap instance).  It makes no guarantees as to the\n iteration order of the set; in particular, it does not guarantee that the\n order will remain constant over time.  This class permits the null\n element.\n\n This class offers constant time performance for the basic operations\n (add, remove, contains and size),\n assuming the hash function disperses the elements properly among the\n buckets.  Iterating over this set requires time proportional to the sum of\n the HashSet instance's size (the number of elements) plus the\n \"capacity\" of the backing HashMap instance (the number of\n buckets).  Thus, it's very important not to set the initial capacity too\n high (or the load factor too low) if iteration performance is important.\n\n Note that this implementation is not synchronized.\n If multiple threads access a hash set concurrently, and at least one of\n the threads modifies the set, it must be synchronized externally.\n This is typically accomplished by synchronizing on some object that\n naturally encapsulates the set.\n\n If no such object exists, the set should be \"wrapped\" using the\n Collections.synchronizedSet\n method.  This is best done at creation time, to prevent accidental\n unsynchronized access to the set:\n   Set s = Collections.synchronizedSet(new HashSet(...));\nThe iterators returned by this class's iterator method are\n fail-fast: if the set is modified at any time after the iterator is\n created, in any way except through the iterator's own remove\n method, the Iterator throws a ConcurrentModificationException.\n Thus, in the face of concurrent modification, the iterator fails quickly\n and cleanly, rather than risking arbitrary, non-deterministic behavior at\n an undetermined time in the future.\n\n Note that the fail-fast behavior of an iterator cannot be guaranteed\n as it is, generally speaking, impossible to make any hard guarantees in the\n presence of unsynchronized concurrent modification.  Fail-fast iterators\n throw ConcurrentModificationException on a best-effort basis.\n Therefore, it would be wrong to write a program that depended on this\n exception for its correctness: the fail-fast behavior of iterators\n should be used only to detect bugs.\nThis class is a member of the\n \n Java Collections Framework.\n\nSince:\n1.2\nSee Also:\nCollection, \nSet, \nTreeSet, \nHashMap, \nSerialized Form", "Set": "Type Parameters:\nE - the type of elements maintained by this set\n\n\nAll Superinterfaces:\nCollection<E>, Iterable<E>\n\n\nAll Known Subinterfaces:\nEventSet, NavigableSet<E>, ObservableSet<E>, ObservableSetValue<E>, SortedSet<E>, WritableSetValue<E>\n\n\nAll Known Implementing Classes:\nAbstractSet, ConcurrentHashMap.KeySetView, ConcurrentSkipListSet, CopyOnWriteArraySet, EnumSet, HashSet, JobStateReasons, LinkedHashSet, ReadOnlySetProperty, ReadOnlySetPropertyBase, ReadOnlySetWrapper, SetBinding, SetExpression, SetProperty, SetPropertyBase, SimpleSetProperty, TreeSet\n\n\npublic interface Set<E>\nextends Collection<E>\nA collection that contains no duplicate elements.  More formally, sets\n contain no pair of elements e1 and e2 such that\n e1.equals(e2), and at most one null element.  As implied by\n its name, this interface models the mathematical set abstraction.\n\n The Set interface places additional stipulations, beyond those\n inherited from the Collection interface, on the contracts of all\n constructors and on the contracts of the add, equals and\n hashCode methods.  Declarations for other inherited methods are\n also included here for convenience.  (The specifications accompanying these\n declarations have been tailored to the Set interface, but they do\n not contain any additional stipulations.)\n\n The additional stipulation on constructors is, not surprisingly,\n that all constructors must create a set that contains no duplicate elements\n (as defined above).\n\n Note: Great care must be exercised if mutable objects are used as set\n elements.  The behavior of a set is not specified if the value of an object\n is changed in a manner that affects equals comparisons while the\n object is an element in the set.  A special case of this prohibition is\n that it is not permissible for a set to contain itself as an element.\n\n Some set implementations have restrictions on the elements that\n they may contain.  For example, some implementations prohibit null elements,\n and some have restrictions on the types of their elements.  Attempting to\n add an ineligible element throws an unchecked exception, typically\n NullPointerException or ClassCastException.  Attempting\n to query the presence of an ineligible element may throw an exception,\n or it may simply return false; some implementations will exhibit the former\n behavior and some will exhibit the latter.  More generally, attempting an\n operation on an ineligible element whose completion would not result in\n the insertion of an ineligible element into the set may throw an\n exception or it may succeed, at the option of the implementation.\n Such exceptions are marked as \"optional\" in the specification for this\n interface.\n\n Unmodifiable Sets\nThe Set.of and\n Set.copyOf static factory methods\n provide a convenient way to create unmodifiable sets. The Set\n instances created by these methods have the following characteristics:\n\n \nThey are unmodifiable. Elements cannot\n be added or removed. Calling any mutator method on the Set\n will always cause UnsupportedOperationException to be thrown.\n However, if the contained elements are themselves mutable, this may cause the\n Set to behave inconsistently or its contents to appear to change.\n They disallow null elements. Attempts to create them with\n null elements result in NullPointerException.\n They are serializable if all elements are serializable.\n They reject duplicate elements at creation time. Duplicate elements\n passed to a static factory method result in IllegalArgumentException.\n The iteration order of set elements is unspecified and is subject to change.\n They are value-based.\n Callers should make no assumptions about the identity of the returned instances.\n Factories are free to create new instances or reuse existing ones. Therefore,\n identity-sensitive operations on these instances (reference equality (==),\n identity hash code, and synchronization) are unreliable and should be avoided.\n They are serialized as specified on the\n Serialized Form\n page.\n \nThis interface is a member of the\n \n Java Collections Framework.\n\nSince:\n1.2\nSee Also:\nCollection, \nList, \nSortedSet, \nHashSet, \nTreeSet, \nAbstractSet, \nCollections.singleton(java.lang.Object), \nCollections.EMPTY_SET", "ArrayBlockingQueue": "Type Parameters:\nE - the type of elements held in this queue\n\n\nAll Implemented Interfaces:\nSerializable, Iterable<E>, Collection<E>, BlockingQueue<E>, Queue<E>\n\n\npublic class ArrayBlockingQueue<E>\nextends AbstractQueue<E>\nimplements BlockingQueue<E>, Serializable\nA bounded blocking queue backed by an\n array.  This queue orders elements FIFO (first-in-first-out).  The\n head of the queue is that element that has been on the\n queue the longest time.  The tail of the queue is that\n element that has been on the queue the shortest time. New elements\n are inserted at the tail of the queue, and the queue retrieval\n operations obtain elements at the head of the queue.\n\n This is a classic \"bounded buffer\", in which a\n fixed-sized array holds elements inserted by producers and\n extracted by consumers.  Once created, the capacity cannot be\n changed.  Attempts to put an element into a full queue\n will result in the operation blocking; attempts to take an\n element from an empty queue will similarly block.\n\n This class supports an optional fairness policy for ordering\n waiting producer and consumer threads.  By default, this ordering\n is not guaranteed. However, a queue constructed with fairness set\n to true grants threads access in FIFO order. Fairness\n generally decreases throughput but reduces variability and avoids\n starvation.\n\n This class and its iterator implement all of the optional\n methods of the Collection and Iterator interfaces.\n\n This class is a member of the\n \n Java Collections Framework.\n\nSince:\n1.5\nSee Also:\nSerialized Form", "BlockingQueue": "Type Parameters:\nE - the type of elements held in this queue\n\n\nAll Superinterfaces:\nCollection<E>, Iterable<E>, Queue<E>\n\n\nAll Known Subinterfaces:\nBlockingDeque<E>, TransferQueue<E>\n\n\nAll Known Implementing Classes:\nArrayBlockingQueue, DelayQueue, LinkedBlockingDeque, LinkedBlockingQueue, LinkedTransferQueue, PriorityBlockingQueue, SynchronousQueue\n\n\npublic interface BlockingQueue<E>\nextends Queue<E>\nA Queue that additionally supports operations that wait for\n the queue to become non-empty when retrieving an element, and wait\n for space to become available in the queue when storing an element.\n\n BlockingQueue methods come in four forms, with different ways\n of handling operations that cannot be satisfied immediately, but may be\n satisfied at some point in the future:\n one throws an exception, the second returns a special value (either\n null or false, depending on the operation), the third\n blocks the current thread indefinitely until the operation can succeed,\n and the fourth blocks for only a given maximum time limit before giving\n up.  These methods are summarized in the following table:\n\n \nSummary of BlockingQueue methods\n\n\nThrows exception\nSpecial value\nBlocks\nTimes out\n\n\nInsert\nadd(e)\noffer(e)\nput(e)\noffer(e, time, unit)\n\n\nRemove\nremove()\npoll()\ntake()\npoll(time, unit)\n\n\nExamine\nelement()\npeek()\nnot applicable\nnot applicable\n\n\nA BlockingQueue does not accept null elements.\n Implementations throw NullPointerException on attempts\n to add, put or offer a null.  A\n null is used as a sentinel value to indicate failure of\n poll operations.\n\n A BlockingQueue may be capacity bounded. At any given\n time it may have a remainingCapacity beyond which no\n additional elements can be put without blocking.\n A BlockingQueue without any intrinsic capacity constraints always\n reports a remaining capacity of Integer.MAX_VALUE.\n\n BlockingQueue implementations are designed to be used\n primarily for producer-consumer queues, but additionally support\n the Collection interface.  So, for example, it is\n possible to remove an arbitrary element from a queue using\n remove(x). However, such operations are in general\n not performed very efficiently, and are intended for only\n occasional use, such as when a queued message is cancelled.\n\n BlockingQueue implementations are thread-safe.  All\n queuing methods achieve their effects atomically using internal\n locks or other forms of concurrency control. However, the\n bulk Collection operations addAll,\n containsAll, retainAll and removeAll are\n not necessarily performed atomically unless specified\n otherwise in an implementation. So it is possible, for example, for\n addAll(c) to fail (throwing an exception) after adding\n only some of the elements in c.\n\n A BlockingQueue does not intrinsically support\n any kind of \"close\" or \"shutdown\" operation to\n indicate that no more items will be added.  The needs and usage of\n such features tend to be implementation-dependent. For example, a\n common tactic is for producers to insert special\n end-of-stream or poison objects, that are\n interpreted accordingly when taken by consumers.\n\n \n Usage example, based on a typical producer-consumer scenario.\n Note that a BlockingQueue can safely be used with multiple\n producers and multiple consumers.\n  \n class Producer implements Runnable {\n   private final BlockingQueue queue;\n   Producer(BlockingQueue q) { queue = q; }\n   public void run() {\n     try {\n       while (true) { queue.put(produce()); }\n     } catch (InterruptedException ex) { ... handle ...}\n   }\n   Object produce() { ... }\n }\n\n class Consumer implements Runnable {\n   private final BlockingQueue queue;\n   Consumer(BlockingQueue q) { queue = q; }\n   public void run() {\n     try {\n       while (true) { consume(queue.take()); }\n     } catch (InterruptedException ex) { ... handle ...}\n   }\n   void consume(Object x) { ... }\n }\n\n class Setup {\n   void main() {\n     BlockingQueue q = new SomeQueueImplementation();\n     Producer p = new Producer(q);\n     Consumer c1 = new Consumer(q);\n     Consumer c2 = new Consumer(q);\n     new Thread(p).start();\n     new Thread(c1).start();\n     new Thread(c2).start();\n   }\n }\nMemory consistency effects: As with other concurrent\n collections, actions in a thread prior to placing an object into a\n BlockingQueue\nhappen-before\n actions subsequent to the access or removal of that element from\n the BlockingQueue in another thread.\n\nThis interface is a member of the\n \n Java Collections Framework.\n\nSince:\n1.5", "ExecutorService": "All Superinterfaces:\nExecutor\n\n\nAll Known Subinterfaces:\nScheduledExecutorService\n\n\nAll Known Implementing Classes:\nAbstractExecutorService, ForkJoinPool, ScheduledThreadPoolExecutor, ThreadPoolExecutor\n\n\npublic interface ExecutorService\nextends Executor\nAn Executor that provides methods to manage termination and\n methods that can produce a Future for tracking progress of\n one or more asynchronous tasks.\n\n An ExecutorService can be shut down, which will cause\n it to reject new tasks.  Two different methods are provided for\n shutting down an ExecutorService. The shutdown()\n method will allow previously submitted tasks to execute before\n terminating, while the shutdownNow() method prevents waiting\n tasks from starting and attempts to stop currently executing tasks.\n Upon termination, an executor has no tasks actively executing, no\n tasks awaiting execution, and no new tasks can be submitted.  An\n unused ExecutorService should be shut down to allow\n reclamation of its resources.\n\n Method submit extends base method Executor.execute(Runnable) by creating and returning a Future\n that can be used to cancel execution and/or wait for completion.\n Methods invokeAny and invokeAll perform the most\n commonly useful forms of bulk execution, executing a collection of\n tasks and then waiting for at least one, or all, to\n complete. (Class ExecutorCompletionService can be used to\n write customized variants of these methods.)\n\n The Executors class provides factory methods for the\n executor services provided in this package.\n\n Usage Examples\n\n Here is a sketch of a network service in which threads in a thread\n pool service incoming requests. It uses the preconfigured Executors.newFixedThreadPool(int) factory method:\n\n  \n class NetworkService implements Runnable {\n   private final ServerSocket serverSocket;\n   private final ExecutorService pool;\n\n   public NetworkService(int port, int poolSize)\n       throws IOException {\n     serverSocket = new ServerSocket(port);\n     pool = Executors.newFixedThreadPool(poolSize);\n   }\n\n   public void run() { // run the service\n     try {\n       for (;;) {\n         pool.execute(new Handler(serverSocket.accept()));\n       }\n     } catch (IOException ex) {\n       pool.shutdown();\n     }\n   }\n }\n\n class Handler implements Runnable {\n   private final Socket socket;\n   Handler(Socket socket) { this.socket = socket; }\n   public void run() {\n     // read and service request on socket\n   }\n }\n\n The following method shuts down an ExecutorService in two phases,\n first by calling shutdown to reject incoming tasks, and then\n calling shutdownNow, if necessary, to cancel any lingering tasks:\n\n  \n void shutdownAndAwaitTermination(ExecutorService pool) {\n   pool.shutdown(); // Disable new tasks from being submitted\n   try {\n     // Wait a while for existing tasks to terminate\n     if (!pool.awaitTermination(60, TimeUnit.SECONDS)) {\n       pool.shutdownNow(); // Cancel currently executing tasks\n       // Wait a while for tasks to respond to being cancelled\n       if (!pool.awaitTermination(60, TimeUnit.SECONDS))\n           System.err.println(\"Pool did not terminate\");\n     }\n   } catch (InterruptedException ie) {\n     // (Re-)Cancel if current thread also interrupted\n     pool.shutdownNow();\n     // Preserve interrupt status\n     Thread.currentThread().interrupt();\n   }\n }\nMemory consistency effects: Actions in a thread prior to the\n submission of a Runnable or Callable task to an\n ExecutorService\nhappen-before\n any actions taken by that task, which in turn happen-before the\n result is retrieved via Future.get().\n\nSince:\n1.5"}