{"LatexParserResult": "Java Components page\nLooking for a different release? Other releases", "Test": "Java Components page\nLooking for a different release? Other releases", "URISyntaxException": "All Implemented Interfaces:\nSerializable\n\n\npublic class URISyntaxException\nextends Exception\nChecked exception thrown to indicate that a string could not be parsed as a\n URI reference.\n\nSince:\n1.4\nSee Also:\nURI, \nSerialized Form", "Path": "All Superinterfaces:\nComparable<Path>, Iterable<Path>, Watchable\n\n\npublic interface Path\nextends Comparable<Path>, Iterable<Path>, Watchable\nAn object that may be used to locate a file in a file system. It will\n typically represent a system dependent file path.\n\n  A Path represents a path that is hierarchical and composed of a\n sequence of directory and file name elements separated by a special separator\n or delimiter. A root component, that identifies a file system\n hierarchy, may also be present. The name element that is farthest\n from the root of the directory hierarchy is the name of a file or directory.\n The other name elements are directory names. A Path can represent a\n root, a root and a sequence of names, or simply one or more name elements.\n A Path is considered to be an empty path if it consists\n solely of one name element that is empty. Accessing a file using an\n empty path is equivalent to accessing the default directory of the\n file system. Path defines the getFileName,\n getParent, getRoot, and subpath methods to access the path components or a subsequence of its name\n elements.\n\n  In addition to accessing the components of a path, a Path also\n defines the resolve and resolveSibling methods to combine paths. The relativize\n method that can be used to construct a relative path between two paths.\n Paths can be compared, and tested against each other using\n the startsWith and endsWith methods.\n\n  This interface extends Watchable interface so that a directory\n located by a path can be registered with a WatchService and entries in the directory watched. \n WARNING: This interface is only intended to be implemented by\n those developing custom file system implementations. Methods may be added to\n this interface in future releases. \nAccessing Files\n Paths may be used with the Files class to operate on files,\n directories, and other types of files. For example, suppose we want a BufferedReader to read text from a file \"access.log\". The\n file is located in a directory \"logs\" relative to the current working\n directory and is UTF-8 encoded.\n \n     Path path = FileSystems.getDefault().getPath(\"logs\", \"access.log\");\n     BufferedReader reader = Files.newBufferedReader(path, StandardCharsets.UTF_8);\n \nInteroperability\n Paths associated with the default provider are generally interoperable\n with the java.io.File class. Paths created by other\n providers are unlikely to be interoperable with the abstract path names\n represented by java.io.File. The toPath\n method may be used to obtain a Path from the abstract path name\n represented by a java.io.File object. The resulting Path can\n be used to operate on the same file as the java.io.File object. In\n addition, the toFile method is useful to construct a \n File from the String representation of a Path.\n\n Concurrency\n Implementations of this interface are immutable and safe for use by\n multiple concurrent threads.\n\nSince:\n1.7\nSee Also:\nPaths", "Arrays": "public class Arrays\nextends Object\nThis class contains various methods for manipulating arrays (such as\n sorting and searching). This class also contains a static factory\n that allows arrays to be viewed as lists.\n\n The methods in this class all throw a NullPointerException,\n if the specified array reference is null, except where noted.\n\n The documentation for the methods contained in this class includes\n brief descriptions of the implementations. Such descriptions should\n be regarded as implementation notes, rather than parts of the\n specification. Implementors should feel free to substitute other\n algorithms, so long as the specification itself is adhered to. (For\n example, the algorithm used by sort(Object[]) does not have to be\n a MergeSort, but it does have to be stable.)\n\n This class is a member of the\n \n Java Collections Framework.\n\nSince:\n1.2", "assertEquals": "Java Components page\nLooking for a different release? Other releases"}