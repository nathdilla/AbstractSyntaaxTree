{"ExternalFileType": "Java Components page\nLooking for a different release? Other releases", "ExternalFileTypes": "Java Components page\nLooking for a different release? Other releases", "UnknownExternalFileType": "Java Components page\nLooking for a different release? Other releases", "MoveFilesCleanup": "Java Components page\nLooking for a different release? Other releases", "RenamePdfCleanup": "Java Components page\nLooking for a different release? Other releases", "IndexingTaskManager": "Java Components page\nLooking for a different release? Other releases", "PdfIndexer": "Java Components page\nLooking for a different release? Other releases", "FileUtil": "Java Components page\nLooking for a different release? Other releases", "BibDatabaseContext": "Java Components page\nLooking for a different release? Other releases", "BibEntry": "Java Components page\nLooking for a different release? Other releases", "LinkedFile": "Java Components page\nLooking for a different release? Other releases", "FilePreferences": "Java Components page\nLooking for a different release? Other releases", "Logger": "Java Components page\nLooking for a different release? Other releases", "LoggerFactory": "Java Components page\nLooking for a different release? Other releases", "IOException": "All Implemented Interfaces:\nSerializable\n\n\nDirect Known Subclasses:\nAttachOperationFailedException, ChangedCharSetException, CharacterCodingException, CharConversionException, ClosedChannelException, ClosedConnectionException, EOFException, FileLockInterruptionException, FileNotFoundException, FilerException, FileSystemException, HttpRetryException, HttpTimeoutException, IIOException, InterruptedByTimeoutException, InterruptedIOException, InvalidPropertiesFormatException, JMXProviderException, JMXServerErrorException, LoadException, MalformedURLException, ObjectStreamException, ProtocolException, RemoteException, SaslException, SocketException, SSLException, SyncFailedException, TransportTimeoutException, UnknownHostException, UnknownServiceException, UnsupportedDataTypeException, UnsupportedEncodingException, UserPrincipalNotFoundException, UTFDataFormatException, WebSocketHandshakeException, ZipException\n\n\npublic class IOException\nextends Exception\nSignals that an I/O exception of some sort has occurred. This\n class is the general class of exceptions produced by failed or\n interrupted I/O operations.\n\nSince:\n1.0\nSee Also:\nInputStream, \nOutputStream, \nSerialized Form", "Path": "All Superinterfaces:\nComparable<Path>, Iterable<Path>, Watchable\n\n\npublic interface Path\nextends Comparable<Path>, Iterable<Path>, Watchable\nAn object that may be used to locate a file in a file system. It will\n typically represent a system dependent file path.\n\n  A Path represents a path that is hierarchical and composed of a\n sequence of directory and file name elements separated by a special separator\n or delimiter. A root component, that identifies a file system\n hierarchy, may also be present. The name element that is farthest\n from the root of the directory hierarchy is the name of a file or directory.\n The other name elements are directory names. A Path can represent a\n root, a root and a sequence of names, or simply one or more name elements.\n A Path is considered to be an empty path if it consists\n solely of one name element that is empty. Accessing a file using an\n empty path is equivalent to accessing the default directory of the\n file system. Path defines the getFileName,\n getParent, getRoot, and subpath methods to access the path components or a subsequence of its name\n elements.\n\n  In addition to accessing the components of a path, a Path also\n defines the resolve and resolveSibling methods to combine paths. The relativize\n method that can be used to construct a relative path between two paths.\n Paths can be compared, and tested against each other using\n the startsWith and endsWith methods.\n\n  This interface extends Watchable interface so that a directory\n located by a path can be registered with a WatchService and entries in the directory watched. \n WARNING: This interface is only intended to be implemented by\n those developing custom file system implementations. Methods may be added to\n this interface in future releases. \nAccessing Files\n Paths may be used with the Files class to operate on files,\n directories, and other types of files. For example, suppose we want a BufferedReader to read text from a file \"access.log\". The\n file is located in a directory \"logs\" relative to the current working\n directory and is UTF-8 encoded.\n \n     Path path = FileSystems.getDefault().getPath(\"logs\", \"access.log\");\n     BufferedReader reader = Files.newBufferedReader(path, StandardCharsets.UTF_8);\n \nInteroperability\n Paths associated with the default provider are generally interoperable\n with the java.io.File class. Paths created by other\n providers are unlikely to be interoperable with the abstract path names\n represented by java.io.File. The toPath\n method may be used to obtain a Path from the abstract path name\n represented by a java.io.File object. The resulting Path can\n be used to operate on the same file as the java.io.File object. In\n addition, the toFile method is useful to construct a \n File from the String representation of a Path.\n\n Concurrency\n Implementations of this interface are immutable and safe for use by\n multiple concurrent threads.\n\nSince:\n1.7\nSee Also:\nPaths", "List": "Type Parameters:\nE - the type of elements in this list\n\n\nAll Superinterfaces:\nCollection<E>, Iterable<E>\n\n\nAll Known Subinterfaces:\nObservableList<E>, ObservableListValue<E>, WritableListValue<E>\n\n\nAll Known Implementing Classes:\nAbstractList, AbstractSequentialList, ArrayList, AttributeList, CopyOnWriteArrayList, FilteredList, LinkedList, ListBinding, ListExpression, ListProperty, ListPropertyBase, ModifiableObservableListBase, ObservableListBase, ReadOnlyListProperty, ReadOnlyListPropertyBase, ReadOnlyListWrapper, RoleList, RoleUnresolvedList, SimpleListProperty, SortedList, Stack, TransformationList, Vector\n\n\npublic interface List<E>\nextends Collection<E>\nAn ordered collection (also known as a sequence).  The user of this\n interface has precise control over where in the list each element is\n inserted.  The user can access elements by their integer index (position in\n the list), and search for elements in the list.\n\n Unlike sets, lists typically allow duplicate elements.  More formally,\n lists typically allow pairs of elements e1 and e2\n such that e1.equals(e2), and they typically allow multiple\n null elements if they allow null elements at all.  It is not inconceivable\n that someone might wish to implement a list that prohibits duplicates, by\n throwing runtime exceptions when the user attempts to insert them, but we\n expect this usage to be rare.\n\n The List interface places additional stipulations, beyond those\n specified in the Collection interface, on the contracts of the\n iterator, add, remove, equals, and\n hashCode methods.  Declarations for other inherited methods are\n also included here for convenience.\n\n The List interface provides four methods for positional (indexed)\n access to list elements.  Lists (like Java arrays) are zero based.  Note\n that these operations may execute in time proportional to the index value\n for some implementations (the LinkedList class, for\n example). Thus, iterating over the elements in a list is typically\n preferable to indexing through it if the caller does not know the\n implementation.\n\n The List interface provides a special iterator, called a\n ListIterator, that allows element insertion and replacement, and\n bidirectional access in addition to the normal operations that the\n Iterator interface provides.  A method is provided to obtain a\n list iterator that starts at a specified position in the list.\n\n The List interface provides two methods to search for a specified\n object.  From a performance standpoint, these methods should be used with\n caution.  In many implementations they will perform costly linear\n searches.\n\n The List interface provides two methods to efficiently insert and\n remove multiple elements at an arbitrary point in the list.\n\n Note: While it is permissible for lists to contain themselves as elements,\n extreme caution is advised: the equals and hashCode\n methods are no longer well defined on such a list.\n\n Some list implementations have restrictions on the elements that\n they may contain.  For example, some implementations prohibit null elements,\n and some have restrictions on the types of their elements.  Attempting to\n add an ineligible element throws an unchecked exception, typically\n NullPointerException or ClassCastException.  Attempting\n to query the presence of an ineligible element may throw an exception,\n or it may simply return false; some implementations will exhibit the former\n behavior and some will exhibit the latter.  More generally, attempting an\n operation on an ineligible element whose completion would not result in\n the insertion of an ineligible element into the list may throw an\n exception or it may succeed, at the option of the implementation.\n Such exceptions are marked as \"optional\" in the specification for this\n interface.\n\n Unmodifiable Lists\nThe List.of and\n List.copyOf static factory methods\n provide a convenient way to create unmodifiable lists. The List\n instances created by these methods have the following characteristics:\n\n \nThey are unmodifiable. Elements cannot\n be added, removed, or replaced. Calling any mutator method on the List\n will always cause UnsupportedOperationException to be thrown.\n However, if the contained elements are themselves mutable,\n this may cause the List's contents to appear to change.\n They disallow null elements. Attempts to create them with\n null elements result in NullPointerException.\n They are serializable if all elements are serializable.\n The order of elements in the list is the same as the order of the\n provided arguments, or of the elements in the provided array.\n They are value-based.\n Callers should make no assumptions about the identity of the returned instances.\n Factories are free to create new instances or reuse existing ones. Therefore,\n identity-sensitive operations on these instances (reference equality (==),\n identity hash code, and synchronization) are unreliable and should be avoided.\n They are serialized as specified on the\n Serialized Form\n page.\n \nThis interface is a member of the\n \n Java Collections Framework.\n\nSince:\n1.2\nSee Also:\nCollection, \nSet, \nArrayList, \nLinkedList, \nVector, \nArrays.asList(Object[]), \nCollections.nCopies(int, Object), \nCollections.EMPTY_LIST, \nAbstractList, \nAbstractSequentialList", "Optional": "Type Parameters:\nT - the type of value\n\n\npublic final class Optional<T>\nextends Object\nA container object which may or may not contain a non-null value.\n If a value is present, isPresent() returns true. If no\n value is present, the object is considered empty and\n isPresent() returns false.\n\n Additional methods that depend on the presence or absence of a contained\n value are provided, such as orElse()\n (returns a default value if no value is present) and\n ifPresent() (performs an\n action if a value is present).\n\n This is a value-based\n class; use of identity-sensitive operations (including reference equality\n (==), identity hash code, or synchronization) on instances of\n Optional may have unpredictable results and should be avoided.\n\nAPI Note:\nOptional is primarily intended for use as a method return type where\n there is a clear need to represent \"no result,\" and where using null\n is likely to cause errors. A variable whose type is Optional should\n never itself be null; it should always point to an Optional\n instance.\nSince:\n1.8"}