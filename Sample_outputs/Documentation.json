{
    "ArrayList": "Type Parameters:\nE - the type of elements in this list\n\n\nAll Implemented Interfaces:\nSerializable, Cloneable, Iterable<E>, Collection<E>, List<E>, RandomAccess\n\n\nDirect Known Subclasses:\nAttributeList, RoleList, RoleUnresolvedList\n\n\npublic class ArrayList<E>\nextends AbstractList<E>\nimplements List<E>, RandomAccess, Cloneable, Serializable\nResizable-array implementation of the List interface.  Implements\n all optional list operations, and permits all elements, including\n null.  In addition to implementing the List interface,\n this class provides methods to manipulate the size of the array that is\n used internally to store the list.  (This class is roughly equivalent to\n Vector, except that it is unsynchronized.)\n\n The size, isEmpty, get, set,\n iterator, and listIterator operations run in constant\n time.  The add operation runs in amortized constant time,\n that is, adding n elements requires O(n) time.  All of the other operations\n run in linear time (roughly speaking).  The constant factor is low compared\n to that for the LinkedList implementation.\n\n Each ArrayList instance has a capacity.  The capacity is\n the size of the array used to store the elements in the list.  It is always\n at least as large as the list size.  As elements are added to an ArrayList,\n its capacity grows automatically.  The details of the growth policy are not\n specified beyond the fact that adding an element has constant amortized\n time cost.\n\n An application can increase the capacity of an ArrayList instance\n before adding a large number of elements using the ensureCapacity\n operation.  This may reduce the amount of incremental reallocation.\n\n Note that this implementation is not synchronized.\n If multiple threads access an ArrayList instance concurrently,\n and at least one of the threads modifies the list structurally, it\n must be synchronized externally.  (A structural modification is\n any operation that adds or deletes one or more elements, or explicitly\n resizes the backing array; merely setting the value of an element is not\n a structural modification.)  This is typically accomplished by\n synchronizing on some object that naturally encapsulates the list.\n\n If no such object exists, the list should be \"wrapped\" using the\n Collections.synchronizedList\n method.  This is best done at creation time, to prevent accidental\n unsynchronized access to the list:\n   List list = Collections.synchronizedList(new ArrayList(...));\n\n The iterators returned by this class's iterator and\n listIterator methods are fail-fast:\n if the list is structurally modified at any time after the iterator is\n created, in any way except through the iterator's own\n remove or\n add methods, the iterator will throw a\n ConcurrentModificationException.  Thus, in the face of\n concurrent modification, the iterator fails quickly and cleanly, rather\n than risking arbitrary, non-deterministic behavior at an undetermined\n time in the future.\n\n Note that the fail-fast behavior of an iterator cannot be guaranteed\n as it is, generally speaking, impossible to make any hard guarantees in the\n presence of unsynchronized concurrent modification.  Fail-fast iterators\n throw ConcurrentModificationException on a best-effort basis.\n Therefore, it would be wrong to write a program that depended on this\n exception for its correctness:  the fail-fast behavior of iterators\n should be used only to detect bugs.\nThis class is a member of the\n \n Java Collections Framework.\n\nSince:\n1.2\nSee Also:\nCollection, \nList, \nLinkedList, \nVector, \nSerialized Form",
    "Random": "All Implemented Interfaces:\nSerializable\n\n\nDirect Known Subclasses:\nSecureRandom, ThreadLocalRandom\n\n\npublic class Random\nextends Object\nimplements Serializable\nAn instance of this class is used to generate a stream of\n pseudorandom numbers. The class uses a 48-bit seed, which is\n modified using a linear congruential formula. (See Donald Knuth,\n The Art of Computer Programming, Volume 2, Section 3.2.1.)\n \n If two instances of Random are created with the same\n seed, and the same sequence of method calls is made for each, they\n will generate and return identical sequences of numbers. In order to\n guarantee this property, particular algorithms are specified for the\n class Random. Java implementations must use all the algorithms\n shown here for the class Random, for the sake of absolute\n portability of Java code. However, subclasses of class Random\n are permitted to use other algorithms, so long as they adhere to the\n general contracts for all the methods.\n \n The algorithms implemented by class Random use a\n protected utility method that on each invocation can supply\n up to 32 pseudorandomly generated bits.\n \n Many applications will find the method Math.random() simpler to use.\n\n Instances of java.util.Random are threadsafe.\n However, the concurrent use of the same java.util.Random\n instance across threads may encounter contention and consequent\n poor performance. Consider instead using\n ThreadLocalRandom in multithreaded\n designs.\n\n Instances of java.util.Random are not cryptographically\n secure.  Consider instead using SecureRandom to\n get a cryptographically secure pseudo-random number generator for use\n by security-sensitive applications.\n\nSince:\n1.0\nSee Also:\nSerialized Form",
    "LocalDate": "All Implemented Interfaces:\nSerializable, Comparable<ChronoLocalDate>, ChronoLocalDate, Temporal, TemporalAccessor, TemporalAdjuster\n\n\npublic final class LocalDate\nextends Object\nimplements Temporal, TemporalAdjuster, ChronoLocalDate, Serializable\nA date without a time-zone in the ISO-8601 calendar system,\n such as 2007-12-03.\n \nLocalDate is an immutable date-time object that represents a date,\n often viewed as year-month-day. Other date fields, such as day-of-year,\n day-of-week and week-of-year, can also be accessed.\n For example, the value \"2nd October 2007\" can be stored in a LocalDate.\n \n This class does not store or represent a time or time-zone.\n Instead, it is a description of the date, as used for birthdays.\n It cannot represent an instant on the time-line without additional information\n such as an offset or time-zone.\n \n The ISO-8601 calendar system is the modern civil calendar system used today\n in most of the world. It is equivalent to the proleptic Gregorian calendar\n system, in which today's rules for leap years are applied for all time.\n For most applications written today, the ISO-8601 rules are entirely suitable.\n However, any application that makes use of historical dates, and requires them\n to be accurate will find the ISO-8601 approach unsuitable.\n\n \n This is a value-based\n class; use of identity-sensitive operations (including reference equality\n (==), identity hash code, or synchronization) on instances of\n LocalDate may have unpredictable results and should be avoided.\n The equals method should be used for comparisons.\n\nImplementation Requirements:\nThis class is immutable and thread-safe.\nSince:\n1.8\nSee Also:\nSerialized Form"
}