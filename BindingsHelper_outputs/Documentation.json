{
    "EasyBind": "Java Components page\nLooking for a different release? Other releases",
    "PreboundBinding": "Java Components page\nLooking for a different release? Other releases",
    "Subscription": "Java Components page\nLooking for a different release? Other releases",
    "BooleanBinding": "All Implemented Interfaces:\nBinding<Boolean>, Observable, ObservableBooleanValue, ObservableValue<Boolean>\n\n\npublic abstract class BooleanBinding\nextends BooleanExpression\nimplements Binding<Boolean>\nBase class that provides most of the functionality needed to implement a\n Binding of a boolean value.\n \nBooleanBinding provides a simple invalidation-scheme. An extending\n class can register dependencies by calling bind(Observable...).\n If One of the registered dependencies becomes invalid, this\n BooleanBinding is marked as invalid. With\n unbind(Observable...) listening to dependencies can be stopped.\n \n To provide a concrete implementation of this class, the method\n computeValue() has to be implemented to calculate the value of this\n binding based on the current state of the dependencies. It is called when\n get() is called for an invalid binding.\n \n See DoubleBinding for an example how this base class can be extended.\n\nSince:\nJavaFX 2.0\nSee Also:\nBinding, \nBooleanExpression",
    "ObjectBinding": "Type Parameters:\nT - the type of the wrapped Object\n\n\nAll Implemented Interfaces:\nBinding<T>, Observable, ObservableObjectValue<T>, ObservableValue<T>\n\n\npublic abstract class ObjectBinding<T>\nextends ObjectExpression<T>\nimplements Binding<T>\nBase class that provides most of the functionality needed to implement a\n Binding of an Object.\n \nObjectBinding provides a simple invalidation-scheme. An extending\n class can register dependencies by calling bind(Observable...).\n If One of the registered dependencies becomes invalid, this\n ObjectBinding is marked as invalid. With\n unbind(Observable...) listening to dependencies can be stopped.\n \n To provide a concrete implementation of this class, the method\n computeValue() has to be implemented to calculate the value of this\n binding based on the current state of the dependencies. It is called when\n get() is called for an invalid binding.\n \n See DoubleBinding for an example how this base class can be extended.\n\nSince:\nJavaFX 2.0\nSee Also:\nBinding, \nObjectExpression",
    "StringBinding": "All Implemented Interfaces:\nBinding<String>, Observable, ObservableObjectValue<String>, ObservableStringValue, ObservableValue<String>\n\n\npublic abstract class StringBinding\nextends StringExpression\nimplements Binding<String>\nBase class that provides most of the functionality needed to implement a\n Binding of a String.\n \nStringBinding provides a simple invalidation-scheme. An extending\n class can register dependencies by calling bind(Observable...).\n If One of the registered dependencies becomes invalid, this\n StringBinding is marked as invalid. With\n unbind(Observable...) listening to dependencies can be stopped.\n \n To provide a concrete implementation of this class, the method\n computeValue() has to be implemented to calculate the value of this\n binding based on the current state of the dependencies. It is called when\n get() is called for an invalid binding.\n \n See DoubleBinding for an example how this base class can be extended.\n\nSince:\nJavaFX 2.0\nSee Also:\nBinding, \nStringExpression",
    "ListProperty": "Type Parameters:\nE - the type of the List elements\n\n\nAll Implemented Interfaces:\nIterable<E>, Collection<E>, List<E>, Observable, Property<ObservableList<E>>, ReadOnlyProperty<ObservableList<E>>, ObservableListValue<E>, ObservableObjectValue<ObservableList<E>>, ObservableValue<ObservableList<E>>, WritableListValue<E>, WritableObjectValue<ObservableList<E>>, WritableValue<ObservableList<E>>, ObservableList<E>\n\n\nDirect Known Subclasses:\nListPropertyBase\n\n\npublic abstract class ListProperty<E>\nextends ReadOnlyListProperty<E>\nimplements Property<ObservableList<E>>, WritableListValue<E>\nThis class provides a full implementation of a Property wrapping an\n ObservableList.\n\n The value of a ListProperty can be get and set with ObservableObjectValue.get(),\n ObservableValue.getValue(), WritableObjectValue.set(Object), and WritableValue.setValue(ObservableList).\n\n A property can be bound and unbound unidirectional with\n Property.bind(javafx.beans.value.ObservableValue) and Property.unbind(). Bidirectional bindings\n can be created and removed with Property.bindBidirectional(Property) and\n Property.unbindBidirectional(Property).\n\n The context of a ListProperty can be read with ReadOnlyProperty.getBean()\n and ReadOnlyProperty.getName().\n\nSince:\nJavaFX 2.1\nSee Also:\nObservableList, \nObservableListValue, \nWritableListValue, \nReadOnlyListProperty, \nProperty",
    "Property": "Type Parameters:\nT - the type of the wrapped value\n\n\nAll Superinterfaces:\nObservable, ObservableValue<T>, ReadOnlyProperty<T>, WritableValue<T>\n\n\nAll Known Subinterfaces:\nJavaBeanProperty<T>\n\n\nAll Known Implementing Classes:\nBooleanProperty, BooleanPropertyBase, DoubleProperty, DoublePropertyBase, FloatProperty, FloatPropertyBase, IntegerProperty, IntegerPropertyBase, JavaBeanBooleanProperty, JavaBeanDoubleProperty, JavaBeanFloatProperty, JavaBeanIntegerProperty, JavaBeanLongProperty, JavaBeanObjectProperty, JavaBeanStringProperty, ListProperty, ListPropertyBase, LongProperty, LongPropertyBase, MapProperty, MapPropertyBase, ObjectProperty, ObjectPropertyBase, ReadOnlyBooleanWrapper, ReadOnlyDoubleWrapper, ReadOnlyFloatWrapper, ReadOnlyIntegerWrapper, ReadOnlyListWrapper, ReadOnlyLongWrapper, ReadOnlyMapWrapper, ReadOnlyObjectWrapper, ReadOnlySetWrapper, ReadOnlyStringWrapper, SetProperty, SetPropertyBase, SimpleBooleanProperty, SimpleDoubleProperty, SimpleFloatProperty, SimpleIntegerProperty, SimpleListProperty, SimpleLongProperty, SimpleMapProperty, SimpleObjectProperty, SimpleSetProperty, SimpleStringProperty, SimpleStyleableBooleanProperty, SimpleStyleableDoubleProperty, SimpleStyleableFloatProperty, SimpleStyleableIntegerProperty, SimpleStyleableLongProperty, SimpleStyleableObjectProperty, SimpleStyleableStringProperty, StringProperty, StringPropertyBase, StyleableBooleanProperty, StyleableDoubleProperty, StyleableFloatProperty, StyleableIntegerProperty, StyleableLongProperty, StyleableObjectProperty, StyleableStringProperty\n\n\npublic interface Property<T>\nextends ReadOnlyProperty<T>, WritableValue<T>\nGeneric interface that defines the methods common to all (writable)\n properties independent of their type.\n\nSince:\nJavaFX 2.0",
    "ChangeListener": "All Known Implementing Classes:\nWeakChangeListener\n\n\nFunctional Interface:\nThis is a functional interface and can therefore be used as the assignment target for a lambda expression or method reference.\n\n\n@FunctionalInterface\npublic interface ChangeListener<T>\nA ChangeListener is notified whenever the value of an\n ObservableValue changes. It can be registered and unregistered with\n ObservableValue.addListener(ChangeListener) respectively\n ObservableValue.removeListener(ChangeListener)\n\n For an in-depth explanation of change events and how they differ from\n invalidation events, see the documentation of ObservableValue.\n \n The same instance of ChangeListener can be registered to listen to\n multiple ObservableValues.\n\nSince:\nJavaFX 2.0\nSee Also:\nObservableValue",
    "ObservableValue": "Type Parameters:\nT - The type of the wrapped value.\n\n\nAll Superinterfaces:\nObservable\n\n\nAll Known Subinterfaces:\nBinding<T>, JavaBeanProperty<T>, NumberBinding, NumberExpression, ObservableBooleanValue, ObservableDoubleValue, ObservableFloatValue, ObservableIntegerValue, ObservableListValue<E>, ObservableLongValue, ObservableMapValue<K,V>, ObservableNumberValue, ObservableObjectValue<T>, ObservableSetValue<E>, ObservableStringValue, Property<T>, ReadOnlyJavaBeanProperty<T>, ReadOnlyProperty<T>, TextInputControl.Content\n\n\nAll Known Implementing Classes:\nBooleanBinding, BooleanExpression, BooleanProperty, BooleanPropertyBase, DoubleBinding, DoubleExpression, DoubleProperty, DoublePropertyBase, FloatBinding, FloatExpression, FloatProperty, FloatPropertyBase, IntegerBinding, IntegerExpression, IntegerProperty, IntegerPropertyBase, JavaBeanBooleanProperty, JavaBeanDoubleProperty, JavaBeanFloatProperty, JavaBeanIntegerProperty, JavaBeanLongProperty, JavaBeanObjectProperty, JavaBeanStringProperty, ListBinding, ListExpression, ListProperty, ListPropertyBase, LongBinding, LongExpression, LongProperty, LongPropertyBase, MapBinding, MapExpression, MapProperty, MapPropertyBase, NumberExpressionBase, ObjectBinding, ObjectExpression, ObjectProperty, ObjectPropertyBase, ObservableValueBase, ReadOnlyBooleanProperty, ReadOnlyBooleanPropertyBase, ReadOnlyBooleanWrapper, ReadOnlyDoubleProperty, ReadOnlyDoublePropertyBase, ReadOnlyDoubleWrapper, ReadOnlyFloatProperty, ReadOnlyFloatPropertyBase, ReadOnlyFloatWrapper, ReadOnlyIntegerProperty, ReadOnlyIntegerPropertyBase, ReadOnlyIntegerWrapper, ReadOnlyJavaBeanBooleanProperty, ReadOnlyJavaBeanDoubleProperty, ReadOnlyJavaBeanFloatProperty, ReadOnlyJavaBeanIntegerProperty, ReadOnlyJavaBeanLongProperty, ReadOnlyJavaBeanObjectProperty, ReadOnlyJavaBeanStringProperty, ReadOnlyListProperty, ReadOnlyListPropertyBase, ReadOnlyListWrapper, ReadOnlyLongProperty, ReadOnlyLongPropertyBase, ReadOnlyLongWrapper, ReadOnlyMapProperty, ReadOnlyMapPropertyBase, ReadOnlyMapWrapper, ReadOnlyObjectProperty, ReadOnlyObjectPropertyBase, ReadOnlyObjectWrapper, ReadOnlySetProperty, ReadOnlySetPropertyBase, ReadOnlySetWrapper, ReadOnlyStringProperty, ReadOnlyStringPropertyBase, ReadOnlyStringWrapper, SetBinding, SetExpression, SetProperty, SetPropertyBase, SimpleBooleanProperty, SimpleDoubleProperty, SimpleFloatProperty, SimpleIntegerProperty, SimpleListProperty, SimpleLongProperty, SimpleMapProperty, SimpleObjectProperty, SimpleSetProperty, SimpleStringProperty, SimpleStyleableBooleanProperty, SimpleStyleableDoubleProperty, SimpleStyleableFloatProperty, SimpleStyleableIntegerProperty, SimpleStyleableLongProperty, SimpleStyleableObjectProperty, SimpleStyleableStringProperty, StringBinding, StringExpression, StringProperty, StringPropertyBase, StyleableBooleanProperty, StyleableDoubleProperty, StyleableFloatProperty, StyleableIntegerProperty, StyleableLongProperty, StyleableObjectProperty, StyleableStringProperty\n\n\npublic interface ObservableValue<T>\nextends Observable\nAn ObservableValue is an entity that wraps a value and allows to\n observe the value for changes. In general this interface should not be\n implemented directly but one of its sub-interfaces\n (ObservableBooleanValue etc.).\n \n The value of the ObservableValue can be requested with\n getValue().\n \n An implementation of ObservableValue may support lazy evaluation,\n which means that the value is not immediately recomputed after changes, but\n lazily the next time the value is requested. All bindings and properties in\n this library support lazy evaluation.\n \n An ObservableValue generates two types of events: change events and\n invalidation events. A change event indicates that the value has changed. An\n invalidation event is generated, if the current value is not valid anymore.\n This distinction becomes important, if the ObservableValue supports\n lazy evaluation, because for a lazily evaluated value one does not know if an\n invalid value really has changed until it is recomputed. For this reason,\n generating change events requires eager evaluation while invalidation events\n can be generated for eager and lazy implementations.\n \n Implementations of this class should strive to generate as few events as\n possible to avoid wasting too much time in event handlers. Implementations in\n this library mark themselves as invalid when the first invalidation event\n occurs. They do not generate anymore invalidation events until their value is\n recomputed and valid again.\n \n Two types of listeners can be attached to an ObservableValue:\n InvalidationListener to listen to invalidation events and\n ChangeListener to listen to change events.\n \n Important note: attaching a ChangeListener enforces eager computation\n even if the implementation of the ObservableValue supports lazy\n evaluation.\n\nSince:\nJavaFX 2.0\nSee Also:\nObservableBooleanValue, \nObservableDoubleValue, \nObservableFloatValue, \nObservableIntegerValue, \nObservableLongValue, \nObservableNumberValue, \nObservableObjectValue, \nObservableStringValue",
    "collections": "Java Components page\nLooking for a different release? Other releases",
    "PseudoClass": "public abstract class PseudoClass\nextends Object\nPseudoClass represents one unique pseudo-class state. Introducing a\n pseudo-class into a JavaFX class only requires that the method\n Node.pseudoClassStateChanged(javafx.css.PseudoClass, boolean)\n be called when the pseudo-class state changes. Typically, the\n pseudoClassStateChanged method is called from the\n protected void invalidated() method of one of the property base\n classes in the javafx.beans.property package.\n \n Note that if a node has a default pseudo-class state, a horizontal orientation\n for example, pseudoClassStateChanged should be called from the\n constructor to set the initial state.\n \n The following example would allow \"xyzzy\" to be used as a\n  pseudo-class in a CSS selector.\n \n  public boolean isMagic() {\n       return magic.get();\n   }\n\n   public BooleanProperty magicProperty() {\n       return magic;\n   }\n\n   public BooleanProperty magic =\n       new BooleanPropertyBase(false) {\n\n       @Override protected void invalidated() {\n           pseudoClassStateChanged(MAGIC_PSEUDO_CLASS. get());\n       }\n\n       @Override public Object getBean() {\n           return MyControl.this;\n       }\n\n       @Override public String getName() {\n           return \"magic\";\n       }\n   }\n\n   private static final PseudoClass\n       MAGIC_PSEUDO_CLASS = PseudoClass.getPseudoClass(\"xyzzy\");\n \n\nSince:\nJavaFX 8.0",
    "Node": "All Implemented Interfaces:\nStyleable, EventTarget\n\n\nDirect Known Subclasses:\nCamera, Canvas, ImageView, LightBase, MediaView, Parent, Shape, Shape3D, SubScene, SwingNode\n\n\n@IDProperty(\"id\")\npublic abstract class Node\nextends Object\nimplements EventTarget, Styleable\nBase class for scene graph nodes. A scene graph is a set of tree data structures\n where every item has zero or one parent, and each item is either\n a \"leaf\" with zero sub-items or a \"branch\" with zero or more sub-items.\n \n Each item in the scene graph is called a Node. Branch nodes are\n of type Parent, whose concrete subclasses are Group,\n Region, and Control,\n or subclasses thereof.\n \n Leaf nodes are classes such as\n Rectangle, Text,\n ImageView, MediaView,\n or other such leaf classes which cannot have children. Only a single node within\n each scene graph tree will have no parent, which is referred to as the \"root\" node.\n \n There may be several trees in the scene graph. Some trees may be part of\n a Scene, in which case they are eligible to be displayed.\n Other trees might not be part of any Scene.\n \n A node may occur at most once anywhere in the scene graph. Specifically,\n a node must appear no more than once in all of the following:\n as the root node of a Scene,\n the children ObservableList of a Parent,\n or as the clip of a Node.\n \n The scene graph must not have cycles. A cycle would exist if a node is\n an ancestor of itself in the tree, considering the Group content\n ObservableList, Parent children ObservableList, and Node clip relationships\n mentioned above.\n \n If a program adds a child node to a Parent (including Group, Region, etc)\n and that node is already a child of a different Parent or the root of a Scene,\n the node is automatically (and silently) removed from its former parent.\n If a program attempts to modify the scene graph in any other way that violates\n the above rules, an exception is thrown, the modification attempt is ignored\n and the scene graph is restored to its previous state.\n \n It is possible to rearrange the structure of the scene graph, for\n example, to move a subtree from one location in the scene graph to\n another. In order to do this, one would normally remove the subtree from\n its old location before inserting it at the new location. However, the\n subtree will be automatically removed as described above if the application\n doesn't explicitly remove it.\n \n Node objects may be constructed and modified on any thread as long they are\n not yet attached to a Scene in a Window that is\n showing.\n An application must attach nodes to such a Scene or modify them on the JavaFX\n Application Thread.\n\n \n The JavaFX Application Thread is created as part of the startup process for\n the JavaFX runtime. See the Application class and\n the Platform.startup(Runnable) method for more information.\n \n\n An application should not extend the Node class directly. Doing so may lead to\n an UnsupportedOperationException being thrown.\n \nString ID\n\n Each node in the scene graph can be given a unique id. This id is\n much like the \"id\" attribute of an HTML tag in that it is up to the designer\n and developer to ensure that the id is unique within the scene graph.\n A convenience function called lookup(String) can be used to find\n a node with a unique id within the scene graph, or within a subtree of the\n scene graph. The id can also be used identify nodes for applying styles; see\n the CSS section below.\n\n Coordinate System\n\n The Node class defines a traditional computer graphics \"local\"\n coordinate system in which the x axis increases to the right and the\n y axis increases downwards.  The concrete node classes for shapes\n provide variables for defining the geometry and location of the shape\n within this local coordinate space.  For example,\n Rectangle provides x, y,\n width, height variables while\n Circle provides centerX, centerY,\n and radius.\n \n At the device pixel level, integer coordinates map onto the corners and\n cracks between the pixels and the centers of the pixels appear at the\n midpoints between integer pixel locations.  Because all coordinate values\n are specified with floating point numbers, coordinates can precisely\n point to these corners (when the floating point values have exact integer\n values) or to any location on the pixel.  For example, a coordinate of\n (0.5, 0.5) would point to the center of the upper left pixel on the\n Stage.  Similarly, a rectangle at (0, 0) with dimensions\n of 10 by 10 would span from the upper left corner of the\n upper left pixel on the Stage to the lower right corner of the\n 10th pixel on the 10th scanline.  The pixel center of the last pixel\n inside that rectangle would be at the coordinates (9.5, 9.5).\n \n In practice, most nodes have transformations applied to their coordinate\n system as mentioned below.  As a result, the information above describing\n the alignment of device coordinates to the pixel grid is relative to\n the transformed coordinates, not the local coordinates of the nodes.\n The Shape class describes some additional\n important context-specific information about coordinate mapping and how\n it can affect rendering.\n\n Transformations\n\n Any Node can have transformations applied to it. These include\n translation, rotation, scaling, or shearing.\n \n A translation transformation is one which shifts the origin of the\n node's coordinate space along either the x or y axis. For example, if you\n create a Rectangle which is drawn at the origin\n (x=0, y=0) and has a width of 100 and a height of 50, and then apply a\n Translate with a shift of 10 along the x axis\n (x=10), then the rectangle will appear drawn at (x=10, y=0) and remain\n 100 points wide and 50 tall. Note that the origin was shifted, not the\n x variable of the rectangle.\n \n A common node transform is a translation by an integer distance, most often\n used to lay out nodes on the stage.  Such integer translations maintain the\n device pixel mapping so that local coordinates that are integers still\n map to the cracks between pixels.\n \n A rotation transformation is one which rotates the coordinate space of\n the node about a specified \"pivot\" point, causing the node to appear rotated.\n For example, if you create a Rectangle which is\n drawn at the origin (x=0, y=0) and has a width of 100 and height of 30 and\n you apply a Rotate with a 90 degree rotation\n (angle=90) and a pivot at the origin (pivotX=0, pivotY=0), then\n the rectangle will be drawn as if its x and y were zero but its height was\n 100 and its width -30. That is, it is as if a pin is being stuck at the top\n left corner and the rectangle is rotating 90 degrees clockwise around that\n pin. If the pivot point is instead placed in the center of the rectangle\n (at point x=50, y=15) then the rectangle will instead appear to rotate about\n its center.\n \n Note that as with all transformations, the x, y, width, and height variables\n of the rectangle (which remain relative to the local coordinate space) have\n not changed, but rather the transformation alters the entire coordinate space\n of the rectangle.\n \n A scaling transformation causes a node to either appear larger or\n smaller depending on the scaling factor. Scaling alters the coordinate space\n of the node such that each unit of distance along the axis in local\n coordinates is multipled by the scale factor. As with rotation\n transformations, scaling transformations are applied about a \"pivot\" point.\n You can think of this as the point in the Node around which you \"zoom\".  For\n example, if you create a Rectangle with a\n strokeWidth of 5, and a width and height of 50, and you apply a\n Scale with scale factors (x=2.0, y=2.0) and\n a pivot at the origin (pivotX=0, pivotY=0), the entire rectangle\n (including the stroke) will double in size, growing to the right and\n downwards from the origin.\n \n A shearing transformation, sometimes called a skew, effectively\n rotates one axis so that the x and y axes are no longer perpendicular.\n \n Multiple transformations may be applied to a node by specifying an ordered\n chain of transforms.  The order in which the transforms are applied is\n defined by the ObservableList specified in the transforms variable.\n\n Bounding Rectangles\n\n Since every Node has transformations, every Node's geometric\n bounding rectangle can be described differently depending on whether\n transformations are accounted for or not.\n \n Each Node has a read-only boundsInLocal\n variable which specifies the bounding rectangle of the Node in\n untransformed local coordinates. boundsInLocal includes the\n Node's shape geometry, including any space required for a\n non-zero stroke that may fall outside the local position/size variables,\n and its clip and effect variables.\n \n Each Node also has a read-only boundsInParent variable which\n specifies the bounding rectangle of the Node after all transformations\n have been applied, including those set in transforms,\n scaleX/scaleY, rotate,\n translateX/translateY, and layoutX/layoutY.\n It is called \"boundsInParent\" because the rectangle will be relative to the\n parent's coordinate system.  This is the 'visual' bounds of the node.\n \n Finally, the layoutBounds variable defines the rectangular bounds of\n the Node that should be used as the basis for layout calculations and\n may differ from the visual bounds of the node.  For shapes, Text, and ImageView,\n layoutBounds by default includes only the shape geometry, including space required\n for a non-zero strokeWidth, but does not include the effect,\n clip, or any transforms. For resizable classes (Regions and Controls)\n layoutBounds will always map to 0,0 width x height.\n\n  The image shows a node without any transformation and its boundsInLocal:\n   \n If we rotate the image by 20 degrees we get following result:\n   \n The red rectangle represents boundsInParent in the\n coordinate space of the Node's parent. The boundsInLocal stays the same\n as in the first image, the green rectangle in this image represents boundsInLocal\n in the coordinate space of the Node.\n\n  The images show a filled and stroked rectangle and their bounds. The\n first rectangle [x:10.0 y:10.0 width:100.0 height:100.0 strokeWidth:0]\n has the following bounds bounds: [x:10.0 y:10.0 width:100.0 height:100.0].\n\n The second rectangle [x:10.0 y:10.0 width:100.0 height:100.0 strokeWidth:5]\n has the following bounds: [x:7.5 y:7.5 width:105 height:105]\n (the stroke is centered by default, so only half of it is outside\n of the original bounds; it is also possible to create inside or outside\n stroke).\n\n Since neither of the rectangles has any transformation applied,\n boundsInParent and boundsInLocal are the same. \n  \nCSS\n\n The Node class contains id, styleClass, and\n style variables that are used in styling this node from\n CSS. The id and styleClass variables are used in\n CSS style sheets to identify nodes to which styles should be\n applied. The style variable contains style properties and\n values that are applied directly to this node.\n \n For further information about CSS and how to apply CSS styles\n to nodes, see the CSS Reference\n Guide.\n\nSince:\nJavaFX 2.0",
    "List": "Type Parameters:\nE - the type of elements in this list\n\n\nAll Superinterfaces:\nCollection<E>, Iterable<E>\n\n\nAll Known Subinterfaces:\nObservableList<E>, ObservableListValue<E>, WritableListValue<E>\n\n\nAll Known Implementing Classes:\nAbstractList, AbstractSequentialList, ArrayList, AttributeList, CopyOnWriteArrayList, FilteredList, LinkedList, ListBinding, ListExpression, ListProperty, ListPropertyBase, ModifiableObservableListBase, ObservableListBase, ReadOnlyListProperty, ReadOnlyListPropertyBase, ReadOnlyListWrapper, RoleList, RoleUnresolvedList, SimpleListProperty, SortedList, Stack, TransformationList, Vector\n\n\npublic interface List<E>\nextends Collection<E>\nAn ordered collection (also known as a sequence).  The user of this\n interface has precise control over where in the list each element is\n inserted.  The user can access elements by their integer index (position in\n the list), and search for elements in the list.\n\n Unlike sets, lists typically allow duplicate elements.  More formally,\n lists typically allow pairs of elements e1 and e2\n such that e1.equals(e2), and they typically allow multiple\n null elements if they allow null elements at all.  It is not inconceivable\n that someone might wish to implement a list that prohibits duplicates, by\n throwing runtime exceptions when the user attempts to insert them, but we\n expect this usage to be rare.\n\n The List interface places additional stipulations, beyond those\n specified in the Collection interface, on the contracts of the\n iterator, add, remove, equals, and\n hashCode methods.  Declarations for other inherited methods are\n also included here for convenience.\n\n The List interface provides four methods for positional (indexed)\n access to list elements.  Lists (like Java arrays) are zero based.  Note\n that these operations may execute in time proportional to the index value\n for some implementations (the LinkedList class, for\n example). Thus, iterating over the elements in a list is typically\n preferable to indexing through it if the caller does not know the\n implementation.\n\n The List interface provides a special iterator, called a\n ListIterator, that allows element insertion and replacement, and\n bidirectional access in addition to the normal operations that the\n Iterator interface provides.  A method is provided to obtain a\n list iterator that starts at a specified position in the list.\n\n The List interface provides two methods to search for a specified\n object.  From a performance standpoint, these methods should be used with\n caution.  In many implementations they will perform costly linear\n searches.\n\n The List interface provides two methods to efficiently insert and\n remove multiple elements at an arbitrary point in the list.\n\n Note: While it is permissible for lists to contain themselves as elements,\n extreme caution is advised: the equals and hashCode\n methods are no longer well defined on such a list.\n\n Some list implementations have restrictions on the elements that\n they may contain.  For example, some implementations prohibit null elements,\n and some have restrictions on the types of their elements.  Attempting to\n add an ineligible element throws an unchecked exception, typically\n NullPointerException or ClassCastException.  Attempting\n to query the presence of an ineligible element may throw an exception,\n or it may simply return false; some implementations will exhibit the former\n behavior and some will exhibit the latter.  More generally, attempting an\n operation on an ineligible element whose completion would not result in\n the insertion of an ineligible element into the list may throw an\n exception or it may succeed, at the option of the implementation.\n Such exceptions are marked as \"optional\" in the specification for this\n interface.\n\n Unmodifiable Lists\nThe List.of and\n List.copyOf static factory methods\n provide a convenient way to create unmodifiable lists. The List\n instances created by these methods have the following characteristics:\n\n \nThey are unmodifiable. Elements cannot\n be added, removed, or replaced. Calling any mutator method on the List\n will always cause UnsupportedOperationException to be thrown.\n However, if the contained elements are themselves mutable,\n this may cause the List's contents to appear to change.\n They disallow null elements. Attempts to create them with\n null elements result in NullPointerException.\n They are serializable if all elements are serializable.\n The order of elements in the list is the same as the order of the\n provided arguments, or of the elements in the provided array.\n They are value-based.\n Callers should make no assumptions about the identity of the returned instances.\n Factories are free to create new instances or reuse existing ones. Therefore,\n identity-sensitive operations on these instances (reference equality (==),\n identity hash code, and synchronization) are unreliable and should be avoided.\n They are serialized as specified on the\n Serialized Form\n page.\n \nThis interface is a member of the\n \n Java Collections Framework.\n\nSince:\n1.2\nSee Also:\nCollection, \nSet, \nArrayList, \nLinkedList, \nVector, \nArrays.asList(Object[]), \nCollections.nCopies(int, Object), \nCollections.EMPTY_LIST, \nAbstractList, \nAbstractSequentialList",
    "Map": "Type Parameters:\nK - the type of keys maintained by this map\nV - the type of mapped values\n\n\nAll Known Subinterfaces:\nBindings, ConcurrentMap<K,V>, ConcurrentNavigableMap<K,V>, LogicalMessageContext, MessageContext, NavigableMap<K,V>, ObservableMap<K,V>, ObservableMapValue<K,V>, SOAPMessageContext, SortedMap<K,V>, WritableMapValue<K,V>\n\n\nAll Known Implementing Classes:\nAbstractMap, Attributes, AuthProvider, ClipboardContent, ConcurrentHashMap, ConcurrentSkipListMap, EnumMap, HashMap, Hashtable, Headers, IdentityHashMap, LinkedHashMap, MapBinding, MapExpression, MapProperty, MapPropertyBase, MultiMapResult, PrinterStateReasons, Properties, Provider, ReadOnlyMapProperty, ReadOnlyMapPropertyBase, ReadOnlyMapWrapper, RenderingHints, ScriptObjectMirror, SimpleBindings, SimpleMapProperty, TabularDataSupport, TreeMap, UIDefaults, WeakHashMap\n\n\npublic interface Map<K,V>\nAn object that maps keys to values.  A map cannot contain duplicate keys;\n each key can map to at most one value.\n\n This interface takes the place of the Dictionary class, which\n was a totally abstract class rather than an interface.\n\n The Map interface provides three collection views, which\n allow a map's contents to be viewed as a set of keys, collection of values,\n or set of key-value mappings.  The order of a map is defined as\n the order in which the iterators on the map's collection views return their\n elements.  Some map implementations, like the TreeMap class, make\n specific guarantees as to their order; others, like the HashMap\n class, do not.\n\n Note: great care must be exercised if mutable objects are used as map\n keys.  The behavior of a map is not specified if the value of an object is\n changed in a manner that affects equals comparisons while the\n object is a key in the map.  A special case of this prohibition is that it\n is not permissible for a map to contain itself as a key.  While it is\n permissible for a map to contain itself as a value, extreme caution is\n advised: the equals and hashCode methods are no longer\n well defined on such a map.\n\n All general-purpose map implementation classes should provide two\n \"standard\" constructors: a void (no arguments) constructor which creates an\n empty map, and a constructor with a single argument of type Map,\n which creates a new map with the same key-value mappings as its argument.\n In effect, the latter constructor allows the user to copy any map,\n producing an equivalent map of the desired class.  There is no way to\n enforce this recommendation (as interfaces cannot contain constructors) but\n all of the general-purpose map implementations in the JDK comply.\n\n The \"destructive\" methods contained in this interface, that is, the\n methods that modify the map on which they operate, are specified to throw\n UnsupportedOperationException if this map does not support the\n operation.  If this is the case, these methods may, but are not required\n to, throw an UnsupportedOperationException if the invocation would\n have no effect on the map.  For example, invoking the putAll(Map)\n method on an unmodifiable map may, but is not required to, throw the\n exception if the map whose mappings are to be \"superimposed\" is empty.\n\n Some map implementations have restrictions on the keys and values they\n may contain.  For example, some implementations prohibit null keys and\n values, and some have restrictions on the types of their keys.  Attempting\n to insert an ineligible key or value throws an unchecked exception,\n typically NullPointerException or ClassCastException.\n Attempting to query the presence of an ineligible key or value may throw an\n exception, or it may simply return false; some implementations will exhibit\n the former behavior and some will exhibit the latter.  More generally,\n attempting an operation on an ineligible key or value whose completion\n would not result in the insertion of an ineligible element into the map may\n throw an exception or it may succeed, at the option of the implementation.\n Such exceptions are marked as \"optional\" in the specification for this\n interface.\n\n Many methods in Collections Framework interfaces are defined\n in terms of the equals method.  For\n example, the specification for the containsKey(Object key) method says: \"returns true if and\n only if this map contains a mapping for a key k such that\n (key==null ? k==null : key.equals(k)).\" This specification should\n not be construed to imply that invoking Map.containsKey\n with a non-null argument key will cause key.equals(k) to\n be invoked for any key k.  Implementations are free to\n implement optimizations whereby the equals invocation is avoided,\n for example, by first comparing the hash codes of the two keys.  (The\n Object.hashCode() specification guarantees that two objects with\n unequal hash codes cannot be equal.)  More generally, implementations of\n the various Collections Framework interfaces are free to take advantage of\n the specified behavior of underlying Object methods wherever the\n implementor deems it appropriate.\n\n Some map operations which perform recursive traversal of the map may fail\n with an exception for self-referential instances where the map directly or\n indirectly contains itself. This includes the clone(),\n equals(), hashCode() and toString() methods.\n Implementations may optionally handle the self-referential scenario, however\n most current implementations do not do so.\n\n Unmodifiable Maps\nThe Map.of,\n Map.ofEntries, and\n Map.copyOf\n static factory methods provide a convenient way to create unmodifiable maps.\n The Map\n instances created by these methods have the following characteristics:\n\n \nThey are unmodifiable. Keys and values\n cannot be added, removed, or updated. Calling any mutator method on the Map\n will always cause UnsupportedOperationException to be thrown.\n However, if the contained keys or values are themselves mutable, this may cause the\n Map to behave inconsistently or its contents to appear to change.\n They disallow null keys and values. Attempts to create them with\n null keys or values result in NullPointerException.\n They are serializable if all keys and values are serializable.\n They reject duplicate keys at creation time. Duplicate keys\n passed to a static factory method result in IllegalArgumentException.\n The iteration order of mappings is unspecified and is subject to change.\n They are value-based.\n Callers should make no assumptions about the identity of the returned instances.\n Factories are free to create new instances or reuse existing ones. Therefore,\n identity-sensitive operations on these instances (reference equality (==),\n identity hash code, and synchronization) are unreliable and should be avoided.\n They are serialized as specified on the\n Serialized Form\n page.\n \nThis interface is a member of the\n \n Java Collections Framework.\n\nSince:\n1.2\nSee Also:\nHashMap, \nTreeMap, \nHashtable, \nSortedMap, \nCollection, \nSet",
    "Consumer": "Type Parameters:\nT - the type of the input to the operation\n\n\nAll Known Subinterfaces:\nStream.Builder<T>\n\n\nFunctional Interface:\nThis is a functional interface and can therefore be used as the assignment target for a lambda expression or method reference.\n\n\n@FunctionalInterface\npublic interface Consumer<T>\nRepresents an operation that accepts a single input argument and returns no\n result. Unlike most other functional interfaces, Consumer is expected\n to operate via side-effects.\n\n This is a functional interface\n whose functional method is accept(Object).\n\nSince:\n1.8",
    "Function": "Type Parameters:\nT - the type of the input to the function\nR - the type of the result of the function\n\n\nAll Known Subinterfaces:\nUnaryOperator<T>\n\n\nFunctional Interface:\nThis is a functional interface and can therefore be used as the assignment target for a lambda expression or method reference.\n\n\n@FunctionalInterface\npublic interface Function<T,R>\nRepresents a function that accepts one argument and produces a result.\n\n This is a functional interface\n whose functional method is apply(Object).\n\nSince:\n1.8"
}