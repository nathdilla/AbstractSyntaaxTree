{
    "java.util.ArrayList": "Type Parameters:\nE - the type of elements in this list\n\n\nAll Implemented Interfaces:\nSerializable, Cloneable, Iterable<E>, Collection<E>, List<E>, RandomAccess\n\n\nDirect Known Subclasses:\nAttributeList, RoleList, RoleUnresolvedList\n\n\npublic class ArrayList<E>\nextends AbstractList<E>\nimplements List<E>, RandomAccess, Cloneable, Serializable\nResizable-array implementation of the List interface.  Implements\n all optional list operations, and permits all elements, including\n null.  In addition to implementing the List interface,\n this class provides methods to manipulate the size of the array that is\n used internally to store the list.  (This class is roughly equivalent to\n Vector, except that it is unsynchronized.)\n\n The size, isEmpty, get, set,\n iterator, and listIterator operations run in constant\n time.  The add operation runs in amortized constant time,\n that is, adding n elements requires O(n) time.  All of the other operations\n run in linear time (roughly speaking).  The constant factor is low compared\n to that for the LinkedList implementation.\n\n Each ArrayList instance has a capacity.  The capacity is\n the size of the array used to store the elements in the list.  It is always\n at least as large as the list size.  As elements are added to an ArrayList,\n its capacity grows automatically.  The details of the growth policy are not\n specified beyond the fact that adding an element has constant amortized\n time cost.\n\n An application can increase the capacity of an ArrayList instance\n before adding a large number of elements using the ensureCapacity\n operation.  This may reduce the amount of incremental reallocation.\n\n Note that this implementation is not synchronized.\n If multiple threads access an ArrayList instance concurrently,\n and at least one of the threads modifies the list structurally, it\n must be synchronized externally.  (A structural modification is\n any operation that adds or deletes one or more elements, or explicitly\n resizes the backing array; merely setting the value of an element is not\n a structural modification.)  This is typically accomplished by\n synchronizing on some object that naturally encapsulates the list.\n\n If no such object exists, the list should be \"wrapped\" using the\n Collections.synchronizedList\n method.  This is best done at creation time, to prevent accidental\n unsynchronized access to the list:\n   List list = Collections.synchronizedList(new ArrayList(...));\n\n The iterators returned by this class's iterator and\n listIterator methods are fail-fast:\n if the list is structurally modified at any time after the iterator is\n created, in any way except through the iterator's own\n remove or\n add methods, the iterator will throw a\n ConcurrentModificationException.  Thus, in the face of\n concurrent modification, the iterator fails quickly and cleanly, rather\n than risking arbitrary, non-deterministic behavior at an undetermined\n time in the future.\n\n Note that the fail-fast behavior of an iterator cannot be guaranteed\n as it is, generally speaking, impossible to make any hard guarantees in the\n presence of unsynchronized concurrent modification.  Fail-fast iterators\n throw ConcurrentModificationException on a best-effort basis.\n Therefore, it would be wrong to write a program that depended on this\n exception for its correctness:  the fail-fast behavior of iterators\n should be used only to detect bugs.\nThis class is a member of the\n \n Java Collections Framework.\n\nSince:\n1.2\nSee Also:\nCollection, \nList, \nLinkedList, \nVector, \nSerialized Form",
    "java.util.Scanner": "All Implemented Interfaces:\nCloseable, AutoCloseable, Iterator<String>\n\n\npublic final class Scanner\nextends Object\nimplements Iterator<String>, Closeable\nA simple text scanner which can parse primitive types and strings using\n regular expressions.\n\n A Scanner breaks its input into tokens using a\n delimiter pattern, which by default matches whitespace. The resulting\n tokens may then be converted into values of different types using the\n various next methods.\n\n For example, this code allows a user to read a number from\n System.in:\n \n     Scanner sc = new Scanner(System.in);\n     int i = sc.nextInt();\n \nAs another example, this code allows long types to be\n assigned from entries in a file myNumbers:\n \n      Scanner sc = new Scanner(new File(\"myNumbers\"));\n      while (sc.hasNextLong()) {\n          long aLong = sc.nextLong();\n      }\n \nThe scanner can also use delimiters other than whitespace. This\n example reads several items in from a string:\n \n     String input = \"1 fish 2 fish red fish blue fish\";\n     Scanner s = new Scanner(input).useDelimiter(\"\\\\s*fish\\\\s*\");\n     System.out.println(s.nextInt());\n     System.out.println(s.nextInt());\n     System.out.println(s.next());\n     System.out.println(s.next());\n     s.close();\n \n\n prints the following output:\n \n     1\n     2\n     red\n     blue\n \nThe same output can be generated with this code, which uses a regular\n expression to parse all four tokens at once:\n \n     String input = \"1 fish 2 fish red fish blue fish\";\n     Scanner s = new Scanner(input);\n     s.findInLine(\"(\\\\d+) fish (\\\\d+) fish (\\\\w+) fish (\\\\w+)\");\n     MatchResult result = s.match();\n     for (int i=1; i<=result.groupCount(); i++)\n         System.out.println(result.group(i));\n     s.close();\n \nThe default whitespace delimiter used\n by a scanner is as recognized by Character.isWhitespace(). The reset()\n method will reset the value of the scanner's delimiter to the default\n whitespace delimiter regardless of whether it was previously changed.\n\n A scanning operation may block waiting for input.\n\n The next() and hasNext() methods and their\n companion methods (such as nextInt() and\n hasNextInt()) first skip any input that matches the delimiter\n pattern, and then attempt to return the next token. Both hasNext()\n and next() methods may block waiting for further input.  Whether a\n hasNext() method blocks has no connection to whether or not its\n associated next() method will block. The tokens() method\n may also block waiting for input.\n\n The findInLine(),\n findWithinHorizon(),\n skip(), and findAll()\n methods operate independently of the delimiter pattern. These methods will\n attempt to match the specified pattern with no regard to delimiters in the\n input and thus can be used in special circumstances where delimiters are\n not relevant. These methods may block waiting for more input.\n\n When a scanner throws an InputMismatchException, the scanner\n will not pass the token that caused the exception, so that it may be\n retrieved or skipped via some other method.\n\n Depending upon the type of delimiting pattern, empty tokens may be\n returned. For example, the pattern \"\\\\s+\" will return no empty\n tokens since it matches multiple instances of the delimiter. The delimiting\n pattern \"\\\\s\" could return empty tokens since it only passes one\n space at a time.\n\n  A scanner can read text from any object which implements the Readable interface.  If an invocation of the underlying\n readable's read() method throws an IOException then the scanner assumes that the end of the input\n has been reached.  The most recent IOException thrown by the\n underlying readable can be retrieved via the ioException() method.\n\n When a Scanner is closed, it will close its input source\n if the source implements the Closeable interface.\n\n A Scanner is not safe for multithreaded use without\n external synchronization.\n\n Unless otherwise mentioned, passing a null parameter into\n any method of a Scanner will cause a\n NullPointerException to be thrown.\n\n A scanner will default to interpreting numbers as decimal unless a\n different radix has been set by using the useRadix(int) method. The\n reset() method will reset the value of the scanner's radix to\n 10 regardless of whether it was previously changed.\n\n  Localized numbers \n An instance of this class is capable of scanning numbers in the standard\n formats as well as in the formats of the scanner's locale. A scanner's\n initial locale is the value returned by the Locale.getDefault(Locale.Category.FORMAT) method; it may be changed via the useLocale() method. The reset() method will reset the value of the\n scanner's locale to the initial locale regardless of whether it was\n previously changed.\n\n The localized formats are defined in terms of the following parameters,\n which for a particular locale are taken from that locale's DecimalFormat object, df, and its and\n DecimalFormatSymbols object,\n dfs.\n\n \nLocalGroupSeparator\u00a0\u00a0\nThe character used to separate thousands groups,\n         i.e.,\u00a0dfs.getGroupingSeparator()\nLocalDecimalSeparator\u00a0\u00a0\nThe character used for the decimal point,\n     i.e.,\u00a0dfs.getDecimalSeparator()\nLocalPositivePrefix\u00a0\u00a0\nThe string that appears before a positive number (may\n         be empty), i.e.,\u00a0df.getPositivePrefix()\nLocalPositiveSuffix\u00a0\u00a0\nThe string that appears after a positive number (may be\n         empty), i.e.,\u00a0df.getPositiveSuffix()\nLocalNegativePrefix\u00a0\u00a0\nThe string that appears before a negative number (may\n         be empty), i.e.,\u00a0df.getNegativePrefix()\nLocalNegativeSuffix\u00a0\u00a0\nThe string that appears after a negative number (may be\n         empty), i.e.,\u00a0df.getNegativeSuffix()\nLocalNaN\u00a0\u00a0\nThe string that represents not-a-number for\n         floating-point values,\n         i.e.,\u00a0dfs.getNaN()\nLocalInfinity\u00a0\u00a0\nThe string that represents infinity for floating-point\n         values, i.e.,\u00a0dfs.getInfinity()\n\n Number syntax \n The strings that can be parsed as numbers by an instance of this class\n are specified in terms of the following regular-expression grammar, where\n Rmax is the highest digit in the radix being used (for example, Rmax is 9 in base 10).\n\n \nNonAsciiDigit:\n       A non-ASCII character c for which\n            Character.isDigit(c)\n                        returns\u00a0true\n\n   Non0Digit:\n       [1-Rmax] | NonASCIIDigit\nDigit:\n       [0-Rmax] | NonASCIIDigit\nGroupedNumeral:\n       (\u00a0Non0Digit\nDigit?\n                   Digit?\n\u00a0\u00a0\u00a0\u00a0(\u00a0LocalGroupSeparator\nDigit\nDigit\nDigit )+ )\nNumeral:\n       ( ( Digit+ )\n               | GroupedNumeral )\nInteger:\n( [-+]? ( Numeral\n                               ) )\n| LocalPositivePrefix Numeral\nLocalPositiveSuffix\n| LocalNegativePrefix Numeral\nLocalNegativeSuffix\nDecimalNumeral:\n       Numeral\n| Numeral\nLocalDecimalSeparator\nDigit*\n| LocalDecimalSeparator\nDigit+\nExponent:\n       ( [eE] [+-]? Digit+ )\nDecimal:\n( [-+]? DecimalNumeral\nExponent? )\n| LocalPositivePrefix\nDecimalNumeral\nLocalPositiveSuffix\nExponent?\n| LocalNegativePrefix\nDecimalNumeral\nLocalNegativeSuffix\nExponent?\nHexFloat:\n       [-+]? 0[xX][0-9a-fA-F]*\\.[0-9a-fA-F]+\n                 ([pP][-+]?[0-9]+)?\nNonNumber:\n       NaN\n                          | LocalNan\n                          | Infinity\n                          | LocalInfinity\nSignedNonNumber:\n       ( [-+]? NonNumber )\n| LocalPositivePrefix\nNonNumber\nLocalPositiveSuffix\n| LocalNegativePrefix\nNonNumber\nLocalNegativeSuffix\nFloat:\n       Decimal\n| HexFloat\n| SignedNonNumber\n\nWhitespace is not significant in the above regular expressions.\n\nSince:\n1.5",
    "java.util.UUID": "All Implemented Interfaces:\nSerializable, Comparable<UUID>\n\n\npublic final class UUID\nextends Object\nimplements Serializable, Comparable<UUID>\nA class that represents an immutable universally unique identifier (UUID).\n A UUID represents a 128-bit value.\n\n  There exist different variants of these global identifiers.  The methods\n of this class are for manipulating the Leach-Salz variant, although the\n constructors allow the creation of any variant of UUID (described below).\n\n  The layout of a variant 2 (Leach-Salz) UUID is as follows:\n\n The most significant long consists of the following unsigned fields:\n \n 0xFFFFFFFF00000000 time_low\n 0x00000000FFFF0000 time_mid\n 0x000000000000F000 version\n 0x0000000000000FFF time_hi\n \n The least significant long consists of the following unsigned fields:\n \n 0xC000000000000000 variant\n 0x3FFF000000000000 clock_seq\n 0x0000FFFFFFFFFFFF node\n \n The variant field contains a value which identifies the layout of the\n UUID.  The bit layout described above is valid only for a \n UUID with a variant value of 2, which indicates the Leach-Salz variant.\n\n  The version field holds a value that describes the type of this \n UUID.  There are four different basic types of UUIDs: time-based, DCE\n security, name-based, and randomly generated UUIDs.  These types have a\n version value of 1, 2, 3 and 4, respectively.\n\n  For more information including algorithms used to create UUIDs,\n see  RFC\u00a04122: A\n Universally Unique IDentifier (UUID) URN Namespace, section 4.2\n \"Algorithms for Creating a Time-Based UUID\".\n\nSince:\n1.5\nSee Also:\nSerialized Form",
    "java.util.Date": "All Implemented Interfaces:\nSerializable, Cloneable, Comparable<Date>\n\n\nDirect Known Subclasses:\nDate, Time, Timestamp\n\n\npublic class Date\nextends Object\nimplements Serializable, Cloneable, Comparable<Date>\nThe class Date represents a specific instant\n in time, with millisecond precision.\n \n Prior to JDK\u00a01.1, the class Date had two additional\n functions.  It allowed the interpretation of dates as year, month, day, hour,\n minute, and second values.  It also allowed the formatting and parsing\n of date strings.  Unfortunately, the API for these functions was not\n amenable to internationalization.  As of JDK\u00a01.1, the\n Calendar class should be used to convert between dates and time\n fields and the DateFormat class should be used to format and\n parse date strings.\n The corresponding methods in Date are deprecated.\n \n Although the Date class is intended to reflect\n coordinated universal time (UTC), it may not do so exactly,\n depending on the host environment of the Java Virtual Machine.\n Nearly all modern operating systems assume that 1\u00a0day\u00a0=\n 24\u00a0\u00d7\u00a060\u00a0\u00d7\u00a060\u00a0= 86400 seconds\n in all cases. In UTC, however, about once every year or two there\n is an extra second, called a \"leap second.\" The leap\n second is always added as the last second of the day, and always\n on December 31 or June 30. For example, the last minute of the\n year 1995 was 61 seconds long, thanks to an added leap second.\n Most computer clocks are not accurate enough to be able to reflect\n the leap-second distinction.\n \n Some computer standards are defined in terms of Greenwich mean\n time (GMT), which is equivalent to universal time (UT).  GMT is\n the \"civil\" name for the standard; UT is the\n \"scientific\" name for the same standard. The\n distinction between UTC and UT is that UTC is based on an atomic\n clock and UT is based on astronomical observations, which for all\n practical purposes is an invisibly fine hair to split. Because the\n earth's rotation is not uniform (it slows down and speeds up\n in complicated ways), UT does not always flow uniformly. Leap\n seconds are introduced as needed into UTC so as to keep UTC within\n 0.9 seconds of UT1, which is a version of UT with certain\n corrections applied. There are other time and date systems as\n well; for example, the time scale used by the satellite-based\n global positioning system (GPS) is synchronized to UTC but is\n not adjusted for leap seconds. An interesting source of\n further information is the United States Naval Observatory (USNO):\n \n     http://www.usno.navy.mil/USNO\n \n\n and the material regarding \"Systems of Time\" at:\n \n     http://www.usno.navy.mil/USNO/time/master-clock/systems-of-time\n \n\n which has descriptions of various different time systems including\n UT, UT1, and UTC.\n \n In all methods of class Date that accept or return\n year, month, date, hours, minutes, and seconds values, the\n following representations are used:\n \nA year y is represented by the integer\n     y\u00a0- 1900.\n A month is represented by an integer from 0 to 11; 0 is January,\n     1 is February, and so forth; thus 11 is December.\n A date (day of month) is represented by an integer from 1 to 31\n     in the usual manner.\n An hour is represented by an integer from 0 to 23. Thus, the hour\n     from midnight to 1 a.m. is hour 0, and the hour from noon to 1\n     p.m. is hour 12.\n A minute is represented by an integer from 0 to 59 in the usual manner.\n A second is represented by an integer from 0 to 61; the values 60 and\n     61 occur only for leap seconds and even then only in Java\n     implementations that actually track leap seconds correctly. Because\n     of the manner in which leap seconds are currently introduced, it is\n     extremely unlikely that two leap seconds will occur in the same\n     minute, but this specification follows the date and time conventions\n     for ISO C.\n \n\n In all cases, arguments given to methods for these purposes need\n not fall within the indicated ranges; for example, a date may be\n specified as January 32 and is interpreted as meaning February 1.\n\nSince:\n1.0\nSee Also:\nDateFormat, \nCalendar, \nTimeZone, \nSerialized Form"
}